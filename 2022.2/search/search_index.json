{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SIB course Single Cell Transcriptomics Warning This course version is currently under construction. The latest stable course version is of November 2021. You can find it here Teachers Tania Wyss .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Rachel Marcone-Jeitziner .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Geert van Geest .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Authors Tania Wyss .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Rachel Marcone-Jeitziner .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Geert van Geest .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Patricia Palagi .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Attribution Parts of this course are inspired by the Broad Institute Single Cell Workshop , and courses previously developed by Walid Gharib at SIB. License & copyright License: CC BY-SA 4.0 Copyright: SIB Swiss Institute of Bioinformatics Learning outcomes General learning outcomes After this course, you will be able to: distinguish advantages and pitfalls of scRNAseq design your own scRNA-seq experiment apply a downstream analysis using R Learning outcomes explained To reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn. Learning experiences To reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only. Exercises Each block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we\u2019ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different. Asking questions During lectures, you are encouraged to raise your hand if you have questions (if in-person), or use the \u201craise hand\u201d Zoom functionality (if online). Find the buttons in the participants list (\u2018Participants\u2019 button): Alternatively, (depending on your zoom version or OS) use the \u2018Reactions\u2019 button: A main source of communication will be our slack channel . Ask background questions that interest you personally at #background . During the exercises, e.g. if you are stuck or don\u2019t understand what is going on, use the slack channel #q-and-a . This channel is not only meant for asking questions but also for answering questions of other participants. If you are replying to a question, use the \u201creply in thread\u201d option: The teacher will review the answers, and add/modify if necessary. If you\u2019re really stuck and need specific tutor support, write the teachers or helpers personally. To summarise: During lectures: raise hand/zoom functionality Personal interest questions: #background During exercises: #q-and-a on slack","title":"Home"},{"location":"#sib-course-single-cell-transcriptomics","text":"Warning This course version is currently under construction. The latest stable course version is of November 2021. You can find it here","title":"SIB course Single Cell Transcriptomics"},{"location":"#teachers","text":"Tania Wyss .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Rachel Marcone-Jeitziner .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Geert van Geest .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;}","title":"Teachers"},{"location":"#authors","text":"Tania Wyss .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Rachel Marcone-Jeitziner .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Geert van Geest .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;} Patricia Palagi .st0{fill:#A6CE39;} .st1{fill:#FFFFFF;}","title":"Authors"},{"location":"#attribution","text":"Parts of this course are inspired by the Broad Institute Single Cell Workshop , and courses previously developed by Walid Gharib at SIB.","title":"Attribution"},{"location":"#license-copyright","text":"License: CC BY-SA 4.0 Copyright: SIB Swiss Institute of Bioinformatics","title":"License &amp; copyright"},{"location":"#learning-outcomes","text":"","title":"Learning outcomes"},{"location":"#general-learning-outcomes","text":"After this course, you will be able to: distinguish advantages and pitfalls of scRNAseq design your own scRNA-seq experiment apply a downstream analysis using R","title":"General learning outcomes"},{"location":"#learning-outcomes-explained","text":"To reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn.","title":"Learning outcomes explained"},{"location":"#learning-experiences","text":"To reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only.","title":"Learning experiences"},{"location":"#exercises","text":"Each block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we\u2019ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different.","title":"Exercises"},{"location":"#asking-questions","text":"During lectures, you are encouraged to raise your hand if you have questions (if in-person), or use the \u201craise hand\u201d Zoom functionality (if online). Find the buttons in the participants list (\u2018Participants\u2019 button): Alternatively, (depending on your zoom version or OS) use the \u2018Reactions\u2019 button: A main source of communication will be our slack channel . Ask background questions that interest you personally at #background . During the exercises, e.g. if you are stuck or don\u2019t understand what is going on, use the slack channel #q-and-a . This channel is not only meant for asking questions but also for answering questions of other participants. If you are replying to a question, use the \u201creply in thread\u201d option: The teacher will review the answers, and add/modify if necessary. If you\u2019re really stuck and need specific tutor support, write the teachers or helpers personally. To summarise: During lectures: raise hand/zoom functionality Personal interest questions: #background During exercises: #q-and-a on slack","title":"Asking questions"},{"location":"course_schedule/","text":"Note Apart from the starting time the time schedule is indicative . Because we can not plan a course by the minute, in practice the time points will deviate. Day 1 block start end subject introduction 9:00 AM 9:30 AM Introduction block 1 9:30 AM 10:30 AM Introduction scRNAseq 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Introduction scRNAseq 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Normalization and scaling 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Quality control Day 2 block start end subject block 1 9:00 AM 10:30 AM Dimensionality reduction 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Cell annotation 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Integration 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Further exercises Day 3 block start end subject block 1 9:00 AM 10:30 AM Differential gene expression 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Differential gene expression 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Enrichment analysis 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Trajectory analysis","title":"Course schedule"},{"location":"course_schedule/#day-1","text":"block start end subject introduction 9:00 AM 9:30 AM Introduction block 1 9:30 AM 10:30 AM Introduction scRNAseq 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Introduction scRNAseq 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Normalization and scaling 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Quality control","title":"Day 1"},{"location":"course_schedule/#day-2","text":"block start end subject block 1 9:00 AM 10:30 AM Dimensionality reduction 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Cell annotation 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Integration 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Further exercises","title":"Day 2"},{"location":"course_schedule/#day-3","text":"block start end subject block 1 9:00 AM 10:30 AM Differential gene expression 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Differential gene expression 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Enrichment analysis 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Trajectory analysis","title":"Day 3"},{"location":"precourse/","text":"Required competences Participants should already have a basic knowledge in Next Generation Sequencing (NGS) techniques, or have already followed the course NGS - Quality control, Alignment, Visualisation . Knowledge in RNA sequencing is a plus. A basic knowledge of the R statistical software is required. Test your R skills with the quiz here , before registering. Software Attendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided. However, in case you wish to perform the practical exercises on your own computer, please take a moment to install the following before the course: R version > 4.0. Latest RStudio version, the free version is perfectly fine. The R packages necessary for the course. Find the script to install them here .","title":"Precourse preparations"},{"location":"precourse/#required-competences","text":"Participants should already have a basic knowledge in Next Generation Sequencing (NGS) techniques, or have already followed the course NGS - Quality control, Alignment, Visualisation . Knowledge in RNA sequencing is a plus. A basic knowledge of the R statistical software is required. Test your R skills with the quiz here , before registering.","title":"Required competences"},{"location":"precourse/#software","text":"Attendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided. However, in case you wish to perform the practical exercises on your own computer, please take a moment to install the following before the course: R version > 4.0. Latest RStudio version, the free version is perfectly fine. The R packages necessary for the course. Find the script to install them here .","title":"Software"},{"location":"day1/general_introduction/","text":"Material Download the presentation","title":"General introduction"},{"location":"day1/general_introduction/#material","text":"Download the presentation","title":"Material"},{"location":"day1/introduction_scrnaseq/","text":"Learning outcomes After having completed this chapter you will be able to: Explain what kind of information single cell RNA-seq can give you to answer a biological question Describe essential considerations during the design of a single cell RNA-seq experiment Describe the pros and cons of different single cell sequencing methods Load single cell data into R Explain the basic structure of a Seurat object and extract count data and metadata Perform a basic quality control by: Evaluating the percentage of UMIs originating from mitochondrial genes Detecting doublets Material Download the presentation Single cell introductory video on iBiology Seurat website Paper on experimental considerations Paper on experimental design SMART-seq3 protocol at protocols.io cellranger system requirements and installation Review by Tallulah Andrews Paper on correlation between mRNA and protein level in single cells Running cellranger count Have a look in the directory course_data/reads and reference . In the reads directory you will find reads on one sample: ETV6-RUNX1_1 . In the analysis part of the course we will work with six samples, but due to time and computational limitations we will run cellranger count on one of the samples, and only reads originating from chromsome 21 and 22. The only thing you need to run cellranger count are the sequence reads and a reference. Here, we have prepared a reference only with chromosome 21 and 22, but in \u2018real life\u2019 you would of course get the full reference genome of your species. The reference has a specific format. You can download precomputed human and mouse references from the 10X website . If your species of interest is not one of those, you will have to generate it yourself. For that, have a look here . Have a look at the documentation of cellranger count (scroll down to Command-line argument reference ), fill out the missing arguments (at FIXME ) in the script below, and run it: cellranger count \\ --id = FIXME \\ --sample = FIXME \\ --transcriptome = FIXME \\ --fastqs = FIXME \\ --localcores = 4 This will take a while.. Once started, the process will need approximately 15 minutes to finish. Have a coffee and/or have a look at the other exercises. Running a bash command with Rstudio You can run a bash script or command using the terminal tab in Rstudio server: Answer cellranger count \\ --id = ETV6-RUNX1_1 \\ --sample = ETV6-RUNX1_1 \\ --transcriptome = cellranger_index \\ --fastqs = course_data/reads \\ --localcores = 4 Have a look out the output directory (i.e. ~/ETV6-RUNX1_1/outs ). The analysis report ( web_summary.html ) is usually a good place to start. Open html files in Rstudio server You can use the file browser in the bottom right (tab \u201cFiles\u201d) to open html files: Exercise: Have a good look inside web_summary.html . Anything that draws your attention? Is this report good enough to continue the analysis? Answer Not really. First of all there is a warning: Fraction of RNA read bases with Q-score >= 30 is low . This means that there is a low base quality of the reads. A low base quality gives results in more sequencing error and therefore possibly lower performance while mapping the reads to genes. However, a Q-score of 30 still represents 99.9% accuracy. What should worry us more is the number of reads per cell (363) and the sequencing saturation (7.9%). In most cases you should aim for 30.000 - 50.000 reads per cell, and a sequencing saturation >~70% (depending on the application). We therefore don\u2019t have enough reads per cell. However, as you might remember, this was a subset of reads (1 million) mapped against chromosome 21 & 22, while the original dataset contains 210,987,037 reads. You can check out the original report at course_data/count_matrices/ETV6-RUNX1_1/outs/web_summary.html . For more info on sequencing saturation, have a look here . Loading scRNAseq data The next step after the generation of the count matrices with cellranger count , is the data analysis. The R package Seurat is currently the most popular software to do this. To start working with Seurat you can load it into your environment like this: library ( Seurat ) Tip: make an R script You could type and copy-paste the commands of these exercises directly in the console. However, that makes it hard to track what you have done. In addition, it can be nice to add comments to your code, so you can read back why you have made certain choices. In order to do that, do not write commands in the console, but write them in a script, and send them to the console with Ctrl + Enter (Windows) or Cmd + Enter (MacOS). First, we will load a file specifying the different samples, and create an object specifying the location of the count data: sample_info <- read.csv ( \"course_data/sample_info_course.csv\" ) datadirs <- file.path ( \"course_data\" , \"count_matrices\" , sample_info $ SampleName , \"outs\" , \"filtered_feature_bc_matrix\" ) names ( datadirs ) <- gsub ( \"_\" , \"-\" , sample_info $ SampleName ) datadirs <- datadirs [ 1 : 3 ] The object datadirs is a named vector specifying the paths of the count directories for each sample: PBMMC-1 \"course_data/count_matrices/PBMMC_1/outs/filtered_feature_bc_matrix\" PBMMC-2 \"course_data/count_matrices/PBMMC_2/outs/filtered_feature_bc_matrix\" PBMMC-3 \"course_data/count_matrices/PBMMC_3/outs/filtered_feature_bc_matrix\" To run through a typical Seurat analysis, we will use the files that are in the directory data/filtered_feature_bc_matrix . This directory is part of the output generated by cellranger . To load this data into R and generate a sparse matrix, run the following command: sparse_matrix <- Seurat :: Read10X ( data.dir = datadirs ) This imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running: sparse_matrix [ c ( \"PECAM1\" , \"CD8A\" , \"TSPAN1\" ), 1 : 30 ] You will see many dots (zeros) and a few integers representing the counts per gene per cell. To generate a Seurat object, we will run CreateSeuratObject : seu <- Seurat :: CreateSeuratObject ( counts = sparse_matrix , project = \"pbmmc\" ) Function notation with :: Here, we define the function together with its associated package. We do that by the syntax package::function . Of course, you can also call library(package) , and only type the function name. Since we use many different packages in this course, it can be confusing which function comes from which package. Therefore, we chose to always associate the package with the called function. Exercise: check what\u2019s in the seu object, by typing seu in the R console. How many features are in there? And how many cells? Answer Typing seu should return: An object of class Seurat 18673 features across 6946 samples within 1 assay Active assay: RNA (18673 features, 0 variable features) This means that we have 18673 genes (features) in there, and 6946 cells (samples) The Seurat object The seu object we have created has the class Seurat . The object contains multi-level slots and lists. Each Seurat object contains exactly the same slots that are specified in the image below (get slot descriptions by typing ?SeuratObject::Seurat ). You can get the information inside a slot with @ , in the same way as you would use the $ for lists (e.g. seu@meta.data will return the a data frame with information on each cell). Slots can be filled with other R objects, like lists, vectors, data frames or any other class. Here\u2019s an overview of all slots that are in a Seurat object: In addition to the original count table, the Seurat object can therefore store a lot of information that is generated during your analysis, like results of a normalization ( @assays$RNA@data ) a PCA or UMAP ( @reductions ) and the clustering ( @graphs ). It also tracks all the commands that have been used to generate the object in its current state ( @commands ). Therefore, while going through the analysis steps, the same object gets more and more of its slots filled. Because most Seurat functions return the input object + adjusted slots, we can use this syntax: seurat_object <- Seurat::function(seurat_object) So, the function takes an object as input and we assign it to an object with the same name. Meaning that we overwrite the object used as input. This is fine in many cases, because Seurat adds information to the input object, and returns is. We will use this syntax for the first time at Normalization and scaling . Getting specific information out of the Seurat object In order to get specific data you can use the @ and $ symbols to browse through the objects. However, Seurat comes with a lot of convenience functions, that are easier to use. So, e.g. to get the raw count matrix, you could type seurat_object@assays$RNA@counts , however, this is equivalent to GetAssayData(object = seurat_object, slot = \"counts\") . More information on these convenience functions here . Exercise: A. Have a look at the seu object by running View(seu) . What is in there? What is stored in @active.ident ? B. Have a look at the data.frame stored at seu@meta.data what kind of information is in there? Answer Answer A There are many slots as described in the above figure. The slot @active.ident contains data specifying the samples, e.g. table(seu@active.ident) returns: PBMMC-1 PBMMC-2 PBMMC-3 1612 3105 2229 Which are the number of cells per sample. Answer B Running head(seu@meta.data) returns: orig.ident nCount_RNA nFeature_RNA PBMMC-1_AAACCTGCAGACGCAA-1 PBMMC-1 2401 909 PBMMC-1_AAACCTGTCATCACCC-1 PBMMC-1 3532 760 PBMMC-1_AAAGATGCATAAAGGT-1 PBMMC-1 3972 1215 PBMMC-1_AAAGCAAAGCAGCGTA-1 PBMMC-1 3569 894 PBMMC-1_AAAGCAACAATAACGA-1 PBMMC-1 2982 730 PBMMC-1_AAAGCAACATCAGTCA-1 PBMMC-1 22284 3108 Giving you the names of three columns and a row for each cell: orig_ident : the original identity (origin) of a cell. nCount_RNA : the number of reads assigned to a cell. nFeature_RNA : the number of expressed features (genes) per cell. Luckily, usually you do not have to dive into this structure to retrieve information. For example, information in the slot @meta.data can be retrieved and set by using $ or [[]] . Note There is a subtle difference here between $ and [[]] . While $ returns a vector of the column in @meta.data , [[]] returns a data.frame . Exercise: Generate a histogram of the column nCount_RNA at seu@meta.data , with the base function hist . Answer hist ( seu $ nCount_RNA ) or hist ( seu @ meta.data $ nCount_RNA ) There are also built-in functions to plot data from Seurat object, for example FeatureScatter . This function enables you easily draw a scatterplot from a Seurat object: Seurat :: FeatureScatter ( seu , feature1 = \"nCount_RNA\" , feature2 = \"nFeature_RNA\" ) You can find a nice overview of such functions here .","title":"Introduction scRNAseq"},{"location":"day1/introduction_scrnaseq/#learning-outcomes","text":"After having completed this chapter you will be able to: Explain what kind of information single cell RNA-seq can give you to answer a biological question Describe essential considerations during the design of a single cell RNA-seq experiment Describe the pros and cons of different single cell sequencing methods Load single cell data into R Explain the basic structure of a Seurat object and extract count data and metadata Perform a basic quality control by: Evaluating the percentage of UMIs originating from mitochondrial genes Detecting doublets","title":"Learning outcomes"},{"location":"day1/introduction_scrnaseq/#material","text":"Download the presentation Single cell introductory video on iBiology Seurat website Paper on experimental considerations Paper on experimental design SMART-seq3 protocol at protocols.io cellranger system requirements and installation Review by Tallulah Andrews Paper on correlation between mRNA and protein level in single cells","title":"Material"},{"location":"day1/introduction_scrnaseq/#running-cellranger-count","text":"Have a look in the directory course_data/reads and reference . In the reads directory you will find reads on one sample: ETV6-RUNX1_1 . In the analysis part of the course we will work with six samples, but due to time and computational limitations we will run cellranger count on one of the samples, and only reads originating from chromsome 21 and 22. The only thing you need to run cellranger count are the sequence reads and a reference. Here, we have prepared a reference only with chromosome 21 and 22, but in \u2018real life\u2019 you would of course get the full reference genome of your species. The reference has a specific format. You can download precomputed human and mouse references from the 10X website . If your species of interest is not one of those, you will have to generate it yourself. For that, have a look here . Have a look at the documentation of cellranger count (scroll down to Command-line argument reference ), fill out the missing arguments (at FIXME ) in the script below, and run it: cellranger count \\ --id = FIXME \\ --sample = FIXME \\ --transcriptome = FIXME \\ --fastqs = FIXME \\ --localcores = 4 This will take a while.. Once started, the process will need approximately 15 minutes to finish. Have a coffee and/or have a look at the other exercises. Running a bash command with Rstudio You can run a bash script or command using the terminal tab in Rstudio server: Answer cellranger count \\ --id = ETV6-RUNX1_1 \\ --sample = ETV6-RUNX1_1 \\ --transcriptome = cellranger_index \\ --fastqs = course_data/reads \\ --localcores = 4 Have a look out the output directory (i.e. ~/ETV6-RUNX1_1/outs ). The analysis report ( web_summary.html ) is usually a good place to start. Open html files in Rstudio server You can use the file browser in the bottom right (tab \u201cFiles\u201d) to open html files: Exercise: Have a good look inside web_summary.html . Anything that draws your attention? Is this report good enough to continue the analysis? Answer Not really. First of all there is a warning: Fraction of RNA read bases with Q-score >= 30 is low . This means that there is a low base quality of the reads. A low base quality gives results in more sequencing error and therefore possibly lower performance while mapping the reads to genes. However, a Q-score of 30 still represents 99.9% accuracy. What should worry us more is the number of reads per cell (363) and the sequencing saturation (7.9%). In most cases you should aim for 30.000 - 50.000 reads per cell, and a sequencing saturation >~70% (depending on the application). We therefore don\u2019t have enough reads per cell. However, as you might remember, this was a subset of reads (1 million) mapped against chromosome 21 & 22, while the original dataset contains 210,987,037 reads. You can check out the original report at course_data/count_matrices/ETV6-RUNX1_1/outs/web_summary.html . For more info on sequencing saturation, have a look here .","title":"Running cellranger count"},{"location":"day1/introduction_scrnaseq/#loading-scrnaseq-data","text":"The next step after the generation of the count matrices with cellranger count , is the data analysis. The R package Seurat is currently the most popular software to do this. To start working with Seurat you can load it into your environment like this: library ( Seurat ) Tip: make an R script You could type and copy-paste the commands of these exercises directly in the console. However, that makes it hard to track what you have done. In addition, it can be nice to add comments to your code, so you can read back why you have made certain choices. In order to do that, do not write commands in the console, but write them in a script, and send them to the console with Ctrl + Enter (Windows) or Cmd + Enter (MacOS). First, we will load a file specifying the different samples, and create an object specifying the location of the count data: sample_info <- read.csv ( \"course_data/sample_info_course.csv\" ) datadirs <- file.path ( \"course_data\" , \"count_matrices\" , sample_info $ SampleName , \"outs\" , \"filtered_feature_bc_matrix\" ) names ( datadirs ) <- gsub ( \"_\" , \"-\" , sample_info $ SampleName ) datadirs <- datadirs [ 1 : 3 ] The object datadirs is a named vector specifying the paths of the count directories for each sample: PBMMC-1 \"course_data/count_matrices/PBMMC_1/outs/filtered_feature_bc_matrix\" PBMMC-2 \"course_data/count_matrices/PBMMC_2/outs/filtered_feature_bc_matrix\" PBMMC-3 \"course_data/count_matrices/PBMMC_3/outs/filtered_feature_bc_matrix\" To run through a typical Seurat analysis, we will use the files that are in the directory data/filtered_feature_bc_matrix . This directory is part of the output generated by cellranger . To load this data into R and generate a sparse matrix, run the following command: sparse_matrix <- Seurat :: Read10X ( data.dir = datadirs ) This imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running: sparse_matrix [ c ( \"PECAM1\" , \"CD8A\" , \"TSPAN1\" ), 1 : 30 ] You will see many dots (zeros) and a few integers representing the counts per gene per cell. To generate a Seurat object, we will run CreateSeuratObject : seu <- Seurat :: CreateSeuratObject ( counts = sparse_matrix , project = \"pbmmc\" ) Function notation with :: Here, we define the function together with its associated package. We do that by the syntax package::function . Of course, you can also call library(package) , and only type the function name. Since we use many different packages in this course, it can be confusing which function comes from which package. Therefore, we chose to always associate the package with the called function. Exercise: check what\u2019s in the seu object, by typing seu in the R console. How many features are in there? And how many cells? Answer Typing seu should return: An object of class Seurat 18673 features across 6946 samples within 1 assay Active assay: RNA (18673 features, 0 variable features) This means that we have 18673 genes (features) in there, and 6946 cells (samples)","title":"Loading scRNAseq data"},{"location":"day1/introduction_scrnaseq/#the-seurat-object","text":"The seu object we have created has the class Seurat . The object contains multi-level slots and lists. Each Seurat object contains exactly the same slots that are specified in the image below (get slot descriptions by typing ?SeuratObject::Seurat ). You can get the information inside a slot with @ , in the same way as you would use the $ for lists (e.g. seu@meta.data will return the a data frame with information on each cell). Slots can be filled with other R objects, like lists, vectors, data frames or any other class. Here\u2019s an overview of all slots that are in a Seurat object: In addition to the original count table, the Seurat object can therefore store a lot of information that is generated during your analysis, like results of a normalization ( @assays$RNA@data ) a PCA or UMAP ( @reductions ) and the clustering ( @graphs ). It also tracks all the commands that have been used to generate the object in its current state ( @commands ). Therefore, while going through the analysis steps, the same object gets more and more of its slots filled. Because most Seurat functions return the input object + adjusted slots, we can use this syntax: seurat_object <- Seurat::function(seurat_object) So, the function takes an object as input and we assign it to an object with the same name. Meaning that we overwrite the object used as input. This is fine in many cases, because Seurat adds information to the input object, and returns is. We will use this syntax for the first time at Normalization and scaling . Getting specific information out of the Seurat object In order to get specific data you can use the @ and $ symbols to browse through the objects. However, Seurat comes with a lot of convenience functions, that are easier to use. So, e.g. to get the raw count matrix, you could type seurat_object@assays$RNA@counts , however, this is equivalent to GetAssayData(object = seurat_object, slot = \"counts\") . More information on these convenience functions here . Exercise: A. Have a look at the seu object by running View(seu) . What is in there? What is stored in @active.ident ? B. Have a look at the data.frame stored at seu@meta.data what kind of information is in there? Answer Answer A There are many slots as described in the above figure. The slot @active.ident contains data specifying the samples, e.g. table(seu@active.ident) returns: PBMMC-1 PBMMC-2 PBMMC-3 1612 3105 2229 Which are the number of cells per sample. Answer B Running head(seu@meta.data) returns: orig.ident nCount_RNA nFeature_RNA PBMMC-1_AAACCTGCAGACGCAA-1 PBMMC-1 2401 909 PBMMC-1_AAACCTGTCATCACCC-1 PBMMC-1 3532 760 PBMMC-1_AAAGATGCATAAAGGT-1 PBMMC-1 3972 1215 PBMMC-1_AAAGCAAAGCAGCGTA-1 PBMMC-1 3569 894 PBMMC-1_AAAGCAACAATAACGA-1 PBMMC-1 2982 730 PBMMC-1_AAAGCAACATCAGTCA-1 PBMMC-1 22284 3108 Giving you the names of three columns and a row for each cell: orig_ident : the original identity (origin) of a cell. nCount_RNA : the number of reads assigned to a cell. nFeature_RNA : the number of expressed features (genes) per cell. Luckily, usually you do not have to dive into this structure to retrieve information. For example, information in the slot @meta.data can be retrieved and set by using $ or [[]] . Note There is a subtle difference here between $ and [[]] . While $ returns a vector of the column in @meta.data , [[]] returns a data.frame . Exercise: Generate a histogram of the column nCount_RNA at seu@meta.data , with the base function hist . Answer hist ( seu $ nCount_RNA ) or hist ( seu @ meta.data $ nCount_RNA ) There are also built-in functions to plot data from Seurat object, for example FeatureScatter . This function enables you easily draw a scatterplot from a Seurat object: Seurat :: FeatureScatter ( seu , feature1 = \"nCount_RNA\" , feature2 = \"nFeature_RNA\" ) You can find a nice overview of such functions here .","title":"The Seurat object"},{"location":"day1/normalization_scaling/","text":"Learning outcomes After having completed this chapter you will be able to: Describe and perform standard procedures for normalization and scaling with the package Seurat Select the most variable genes from a Seurat object for downstream analyses Material Seurat vignette Exercises Normalization After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method \"LogNormalize\" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in the \u201cRNA\u201d assay (as item of the @assay slot) of the seu object. Exercise: Have a look at the assay data before and after running NormalizeData() . Did it change? Hint You can extract assay data with the function Seurat::GetAssayData . By default, the slot data is used, containing raw counts before normalization, and normalized counts after normalization. Use Seurat::GetAssayData(seu, slot = \"counts\") to get the raw count data after normalization. Answer You can check out some assay data with: Seurat :: GetAssayData ( seu )[ 1 : 10 , 1 : 10 ] Returning: Before normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018PBMMC-1_AAACCTGCAGACGCAA-1\u2019, \u2018PBMMC-1_AAACCTGTCATCACCC-1\u2019, \u2018PBMMC-1_AAAGATGCATAAAGGT-1\u2019 ... ]] RP11-34P13.7 . . . . . . . . . . FO538757.3 . . . . . . . . . . FO538757.2 1 . . . . . 2 . . . AP006222.2 . . . . . . . . . . RP4-669L17.10 . . . . . . . . . . RP5-857K21.4 . . . . . . . . . . RP11-206L10.9 . . . . . . . . . . LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . RP11-54O7.1 . . . . . . . . . . After normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018PBMMC-1_AAACCTGCAGACGCAA-1\u2019, \u2018PBMMC-1_AAACCTGTCATCACCC-1\u2019, \u2018PBMMC-1_AAAGATGCATAAAGGT-1\u2019 ... ]] RP11-34P13.7 . . . . . . . . . . FO538757.3 . . . . . . . . . . FO538757.2 1.641892 . . . . . 1.381104 . . . AP006222.2 . . . . . . . . . . RP4-669L17.10 . . . . . . . . . . RP5-857K21.4 . . . . . . . . . . RP11-206L10.9 . . . . . . . . . . LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . RP11-54O7.1 . . . . . . . . . . seu <- Seurat :: NormalizeData ( seu , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) Updating seu As you might have noticed, this function takes the object seu as input, and it returns it to an object named seu . We can do this because the output of such calculations are added to the object, without loosing information. Variable features We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, 2,000 genes (features) per dataset are returned and these will be used in downstream analysis, like PCA. seu <- Seurat :: FindVariableFeatures ( seu , selection.method = \"vst\" , nfeatures = 2000 ) Let\u2019s have a look at the 10 most variable genes: # Identify the 10 most highly variable genes top10 <- head ( Seurat :: VariableFeatures ( seu ), 10 ) top10 We can plot them in a nicely labeled scatterplot: vf_plot <- Seurat :: VariableFeaturePlot ( seu ) Seurat :: LabelPoints ( plot = vf_plot , points = top10 , repel = TRUE ) You can see that most of the highly variables are antibody subunits (starting with IGH, IGL). Not very surprising since we look at bone marrow tissue. We can have a look later in which cells they are expressed. Scaling Next, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function shifts the expression of each gene, so that the mean expression across cells is 0 scales the expression of each gene, so that the variance across cells is 1 This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate. The results of this are stored in seu$RNA@scale.data seu <- Seurat :: ScaleData ( seu , features = rownames ( seu )) The use of Seurat::SCTransform The functions NormalizeData , VariableFeatures and ScaleData can be replaced by the function SCTransform . The latter uses a more sophisticated way to perform the normalization and scaling, and is argued to perform better . However, it is slower, and a bit less transparent compared to using the three separate functions. Therefore, we chose not to use SCTransform for the exercises. Bonus exercise : Run SCTransform on the seu object. Where is the output stored? Answer You can run it like so: seu <- Seurat :: SCTransform ( seu ) And it will add an extra assay to the object. names(seu@assay) returns: [1] \"RNA\" \"SCT\" Meaning that a whole new assay was added (including the sparse matrices with counts, normalized data and scaled data). Warning Running SCTransform will change @active.assay into SCT (in stead of RNA ; check it with DefaultAssay(seu) ). This assay is used as a default for following function calls. To change the active assay to RNA run: DefaultAssay ( seu ) <- \"RNA\" Save the dataset and clear environment Now, save the dataset so you can use it tomorrow: saveRDS ( seu , \"seu_day1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Normalization and scaling"},{"location":"day1/normalization_scaling/#learning-outcomes","text":"After having completed this chapter you will be able to: Describe and perform standard procedures for normalization and scaling with the package Seurat Select the most variable genes from a Seurat object for downstream analyses","title":"Learning outcomes"},{"location":"day1/normalization_scaling/#material","text":"Seurat vignette","title":"Material"},{"location":"day1/normalization_scaling/#exercises","text":"","title":"Exercises"},{"location":"day1/normalization_scaling/#normalization","text":"After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method \"LogNormalize\" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in the \u201cRNA\u201d assay (as item of the @assay slot) of the seu object. Exercise: Have a look at the assay data before and after running NormalizeData() . Did it change? Hint You can extract assay data with the function Seurat::GetAssayData . By default, the slot data is used, containing raw counts before normalization, and normalized counts after normalization. Use Seurat::GetAssayData(seu, slot = \"counts\") to get the raw count data after normalization. Answer You can check out some assay data with: Seurat :: GetAssayData ( seu )[ 1 : 10 , 1 : 10 ] Returning: Before normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018PBMMC-1_AAACCTGCAGACGCAA-1\u2019, \u2018PBMMC-1_AAACCTGTCATCACCC-1\u2019, \u2018PBMMC-1_AAAGATGCATAAAGGT-1\u2019 ... ]] RP11-34P13.7 . . . . . . . . . . FO538757.3 . . . . . . . . . . FO538757.2 1 . . . . . 2 . . . AP006222.2 . . . . . . . . . . RP4-669L17.10 . . . . . . . . . . RP5-857K21.4 . . . . . . . . . . RP11-206L10.9 . . . . . . . . . . LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . RP11-54O7.1 . . . . . . . . . . After normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018PBMMC-1_AAACCTGCAGACGCAA-1\u2019, \u2018PBMMC-1_AAACCTGTCATCACCC-1\u2019, \u2018PBMMC-1_AAAGATGCATAAAGGT-1\u2019 ... ]] RP11-34P13.7 . . . . . . . . . . FO538757.3 . . . . . . . . . . FO538757.2 1.641892 . . . . . 1.381104 . . . AP006222.2 . . . . . . . . . . RP4-669L17.10 . . . . . . . . . . RP5-857K21.4 . . . . . . . . . . RP11-206L10.9 . . . . . . . . . . LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . RP11-54O7.1 . . . . . . . . . . seu <- Seurat :: NormalizeData ( seu , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) Updating seu As you might have noticed, this function takes the object seu as input, and it returns it to an object named seu . We can do this because the output of such calculations are added to the object, without loosing information.","title":"Normalization"},{"location":"day1/normalization_scaling/#variable-features","text":"We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, 2,000 genes (features) per dataset are returned and these will be used in downstream analysis, like PCA. seu <- Seurat :: FindVariableFeatures ( seu , selection.method = \"vst\" , nfeatures = 2000 ) Let\u2019s have a look at the 10 most variable genes: # Identify the 10 most highly variable genes top10 <- head ( Seurat :: VariableFeatures ( seu ), 10 ) top10 We can plot them in a nicely labeled scatterplot: vf_plot <- Seurat :: VariableFeaturePlot ( seu ) Seurat :: LabelPoints ( plot = vf_plot , points = top10 , repel = TRUE ) You can see that most of the highly variables are antibody subunits (starting with IGH, IGL). Not very surprising since we look at bone marrow tissue. We can have a look later in which cells they are expressed.","title":"Variable features"},{"location":"day1/normalization_scaling/#scaling","text":"Next, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function shifts the expression of each gene, so that the mean expression across cells is 0 scales the expression of each gene, so that the variance across cells is 1 This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate. The results of this are stored in seu$RNA@scale.data seu <- Seurat :: ScaleData ( seu , features = rownames ( seu )) The use of Seurat::SCTransform The functions NormalizeData , VariableFeatures and ScaleData can be replaced by the function SCTransform . The latter uses a more sophisticated way to perform the normalization and scaling, and is argued to perform better . However, it is slower, and a bit less transparent compared to using the three separate functions. Therefore, we chose not to use SCTransform for the exercises. Bonus exercise : Run SCTransform on the seu object. Where is the output stored? Answer You can run it like so: seu <- Seurat :: SCTransform ( seu ) And it will add an extra assay to the object. names(seu@assay) returns: [1] \"RNA\" \"SCT\" Meaning that a whole new assay was added (including the sparse matrices with counts, normalized data and scaled data). Warning Running SCTransform will change @active.assay into SCT (in stead of RNA ; check it with DefaultAssay(seu) ). This assay is used as a default for following function calls. To change the active assay to RNA run: DefaultAssay ( seu ) <- \"RNA\"","title":"Scaling"},{"location":"day1/normalization_scaling/#save-the-dataset-and-clear-environment","text":"Now, save the dataset so you can use it tomorrow: saveRDS ( seu , \"seu_day1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day1/quality_control/","text":"Learning outcomes After having completed this chapter you will be able to: Calculate and visualize quality measures based on: mitochondrial genes ribosomal genes hemoglobin genes relative gene expression Interpret the above quality measures per cell. Perform cell filtering based on quality thresholds Material Download the presentation Exercises Visualizing QC per cell and gene While generating the Seurat object, there were already some quality measures calculated for each cell, namely the total UMI counts per cell ( nCount_RNA ) and the total number of detected features per cell ( nFeature_RNA ). We can plot those in a violin plot and evaluate their distribution per sample: Seurat :: VlnPlot ( seu , features = c ( \"nCount_RNA\" , \"nFeature_RNA\" )) You can see that there is quite a wide range for both. A cell with low number of detected features or counts might not give you a lot of information, while a high number of detected features/counts might point to doublets. Single cells have often undergone sampling and/or dissociation and/or sorting. Therefore, there are often cells and genes in your dataset that cause variation due to technical reasons. In the following steps, we will visualize those and make decisions on whether or not to remove cells or genes with extreme values. We will start with calculating the percentage of counts coming from transcript types: Mitochondrial genes : If a cell membrane is damaged, it looses free RNA quicker compared to mitochondrial RNA, because the latter is part of the mitochondrion. A high relative amount of mitochondrial counts can therefore point to damaged cells ( Lun et al. 2016 ). Ribosomal genes : Although rRNA transcripts are depleted due to poly-A enrichment, they are often abundant. They do not point to specific issues, but it can be good to have a look at their relative abundance. Sometimes, they might even have a biological relevance (e.g. Caron et al. 2020 ). Hemoglobin genes : these transcripts are very abundant in erythrocytes. Depending on your application, you can expect \u2018contamination\u2019 of erythrocytes and select against it. In order to have an idea about the relative counts of these type of genes in our dataset, we can calculate their expression as relative counts in each cell. We do that by selecting genes based on patterns (e.g. ^MT- matches with all gene names starting with MT , i.e. mitochondrial genes): # mitochondrial genes seu <- Seurat :: PercentageFeatureSet ( seu , pattern = \"^MT-\" , col.name = \"percent.mito\" ) # ribosomal genes seu <- Seurat :: PercentageFeatureSet ( seu , pattern = \"^RP[SL]\" , col.name = \"percent.ribo\" ) # hemoglobin genes (but not HBP) seu <- Seurat :: PercentageFeatureSet ( seu , pattern = \"^HB[^(P)]\" , col.name = \"percent.globin\" ) Exercise: Run the commands and check out the metadata data frame at sc@meta.data . What has changed? Answer If we type head(sc@meta.data) it returns: orig.ident nCount_RNA nFeature_RNA percent.mito percent.ribo percent.globin PBMMC-1_AAACCTGCAGACGCAA-1 PBMMC-1 2401 909 2.540608 28.65473 0.1665973 PBMMC-1_AAACCTGTCATCACCC-1 PBMMC-1 3532 760 5.181200 55.03964 0.1981880 PBMMC-1_AAAGATGCATAAAGGT-1 PBMMC-1 3972 1215 4.934542 30.43807 0.3776435 PBMMC-1_AAAGCAAAGCAGCGTA-1 PBMMC-1 3569 894 3.250210 55.02942 0.3642477 PBMMC-1_AAAGCAACAATAACGA-1 PBMMC-1 2982 730 3.688799 54.49363 0.1006036 PBMMC-1_AAAGCAACATCAGTCA-1 PBMMC-1 22284 3108 3.181655 23.40693 36.9682283 So, the function PercentageFeatureSet adds a column to meta.data , specifying the percentage of counts for the specified gene sets. Now we can plot the distribution of these percentages in a violin plot: Seurat :: VlnPlot ( seu , features = c ( \"percent.mito\" , \"percent.ribo\" , \"percent.globin\" )) You can see that PBMMC-2 is quite different from the two others, it has a group of cells with very low ribosomal counts and one with very high globin counts. Maybe these two percentages are negatively correlated? Let\u2019s have a look, by plotting the two percentages against each other: Seurat :: FeatureScatter ( seu , feature1 = \"percent.globin\" , feature2 = \"percent.ribo\" ) Exercise: Are they correlated? What kind of cells might have a high abundance of hemoglobin transcripts and low ribosomal transcripts? Answer Yes there is a negative correlation: Erythrocytes (red blood cells) have a high abundance of hemoglobin transcripts and low abundance of ribosomal transcripts. These are most likely erythroid cells, i.e. the cells predecessing erythrocytes in the bone marrow. We can also evaluate the relative expression of other genes in our dataset, for example, the ones that are most highly expressed. Some very highly expressed genes might point to a technical cause, and we might consider to remove them. Below you will find a simple function to generate a boxplot of relative counts per gene per cell. Load it into your environment and run it on our seu object: library ( ggplot2 ) library ( Matrix ) library ( Seurat ) most_expressed_boxplot <- function ( object , ngenes = 20 ){ # matrix of raw counts cts <- Seurat :: GetAssayData ( seu , assay = \"RNA\" , slot = \"counts\" ) # get percentage/cell cts <- t ( cts ) / colSums ( cts ) * 100 medians <- apply ( cts , 2 , median ) # get top n genes most_expressed <- order ( medians , decreasing = T )[ ngenes : 1 ] most_exp_matrix <- as.matrix (( cts [, most_expressed ])) # prepare for plotting most_exp_df <- stack ( as.data.frame ( most_exp_matrix )) colnames ( most_exp_df ) <- c ( \"perc_total\" , \"gene\" ) # boxplot with ggplot2 boxplot <- ggplot ( most_exp_df , aes ( x = gene , y = perc_total )) + geom_boxplot () + coord_flip () return ( boxplot ) } most_expressed_boxplot ( seu , 20 ) As for most 10X based poly-A enriched single cell datasets, we find a relatively high expression of MALAT1. Many researchers choose to remove it, but it can have biological relevance (e.g. Shaat et al. 2021 ). Cell filtering Based on the QC process we went through we can come to the following conclusions: There are no cells with very high mitochondrial gene counts. There are some cells with a hemoglobin and low ribosomal counts, and these are probably erythrocytes. There are some cells with a very low and very high number of features. These might point to non-informative cells and doublets respectively. The \u2018usual suspect\u2019 MALAT1 sometimes makes up a large part of the counts per cell. As we do not see any other suggestions of dying/stressed cells, we leave it in. In this case, a sensible decision would be to do mild filtering on the number of features per cell and mitochondrial counts. We can leave the possible erythrocytes in for now, and see where they end up later during the dimensionality reduction. In the M&M of the publication , the authors describe that they have used a threshold of < 8% mitochondrial counts and > 200 features per cell. To filter against possible doublets, here, we also filter out cells with > 5000 detected features/cell. Filtering Seurat objects can be done with the subset method for class SeuratObject : seu <- subset ( seu , subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mito < 8 ) To evaluate this did the trick we can visualize those parameters again in a violin plot: Seurat :: VlnPlot ( seu , features = c ( \"nFeature_RNA\" , \"percent.mito\" ))","title":"Quality control"},{"location":"day1/quality_control/#learning-outcomes","text":"After having completed this chapter you will be able to: Calculate and visualize quality measures based on: mitochondrial genes ribosomal genes hemoglobin genes relative gene expression Interpret the above quality measures per cell. Perform cell filtering based on quality thresholds","title":"Learning outcomes"},{"location":"day1/quality_control/#material","text":"Download the presentation","title":"Material"},{"location":"day1/quality_control/#exercises","text":"","title":"Exercises"},{"location":"day1/quality_control/#visualizing-qc-per-cell-and-gene","text":"While generating the Seurat object, there were already some quality measures calculated for each cell, namely the total UMI counts per cell ( nCount_RNA ) and the total number of detected features per cell ( nFeature_RNA ). We can plot those in a violin plot and evaluate their distribution per sample: Seurat :: VlnPlot ( seu , features = c ( \"nCount_RNA\" , \"nFeature_RNA\" )) You can see that there is quite a wide range for both. A cell with low number of detected features or counts might not give you a lot of information, while a high number of detected features/counts might point to doublets. Single cells have often undergone sampling and/or dissociation and/or sorting. Therefore, there are often cells and genes in your dataset that cause variation due to technical reasons. In the following steps, we will visualize those and make decisions on whether or not to remove cells or genes with extreme values. We will start with calculating the percentage of counts coming from transcript types: Mitochondrial genes : If a cell membrane is damaged, it looses free RNA quicker compared to mitochondrial RNA, because the latter is part of the mitochondrion. A high relative amount of mitochondrial counts can therefore point to damaged cells ( Lun et al. 2016 ). Ribosomal genes : Although rRNA transcripts are depleted due to poly-A enrichment, they are often abundant. They do not point to specific issues, but it can be good to have a look at their relative abundance. Sometimes, they might even have a biological relevance (e.g. Caron et al. 2020 ). Hemoglobin genes : these transcripts are very abundant in erythrocytes. Depending on your application, you can expect \u2018contamination\u2019 of erythrocytes and select against it. In order to have an idea about the relative counts of these type of genes in our dataset, we can calculate their expression as relative counts in each cell. We do that by selecting genes based on patterns (e.g. ^MT- matches with all gene names starting with MT , i.e. mitochondrial genes): # mitochondrial genes seu <- Seurat :: PercentageFeatureSet ( seu , pattern = \"^MT-\" , col.name = \"percent.mito\" ) # ribosomal genes seu <- Seurat :: PercentageFeatureSet ( seu , pattern = \"^RP[SL]\" , col.name = \"percent.ribo\" ) # hemoglobin genes (but not HBP) seu <- Seurat :: PercentageFeatureSet ( seu , pattern = \"^HB[^(P)]\" , col.name = \"percent.globin\" ) Exercise: Run the commands and check out the metadata data frame at sc@meta.data . What has changed? Answer If we type head(sc@meta.data) it returns: orig.ident nCount_RNA nFeature_RNA percent.mito percent.ribo percent.globin PBMMC-1_AAACCTGCAGACGCAA-1 PBMMC-1 2401 909 2.540608 28.65473 0.1665973 PBMMC-1_AAACCTGTCATCACCC-1 PBMMC-1 3532 760 5.181200 55.03964 0.1981880 PBMMC-1_AAAGATGCATAAAGGT-1 PBMMC-1 3972 1215 4.934542 30.43807 0.3776435 PBMMC-1_AAAGCAAAGCAGCGTA-1 PBMMC-1 3569 894 3.250210 55.02942 0.3642477 PBMMC-1_AAAGCAACAATAACGA-1 PBMMC-1 2982 730 3.688799 54.49363 0.1006036 PBMMC-1_AAAGCAACATCAGTCA-1 PBMMC-1 22284 3108 3.181655 23.40693 36.9682283 So, the function PercentageFeatureSet adds a column to meta.data , specifying the percentage of counts for the specified gene sets. Now we can plot the distribution of these percentages in a violin plot: Seurat :: VlnPlot ( seu , features = c ( \"percent.mito\" , \"percent.ribo\" , \"percent.globin\" )) You can see that PBMMC-2 is quite different from the two others, it has a group of cells with very low ribosomal counts and one with very high globin counts. Maybe these two percentages are negatively correlated? Let\u2019s have a look, by plotting the two percentages against each other: Seurat :: FeatureScatter ( seu , feature1 = \"percent.globin\" , feature2 = \"percent.ribo\" ) Exercise: Are they correlated? What kind of cells might have a high abundance of hemoglobin transcripts and low ribosomal transcripts? Answer Yes there is a negative correlation: Erythrocytes (red blood cells) have a high abundance of hemoglobin transcripts and low abundance of ribosomal transcripts. These are most likely erythroid cells, i.e. the cells predecessing erythrocytes in the bone marrow. We can also evaluate the relative expression of other genes in our dataset, for example, the ones that are most highly expressed. Some very highly expressed genes might point to a technical cause, and we might consider to remove them. Below you will find a simple function to generate a boxplot of relative counts per gene per cell. Load it into your environment and run it on our seu object: library ( ggplot2 ) library ( Matrix ) library ( Seurat ) most_expressed_boxplot <- function ( object , ngenes = 20 ){ # matrix of raw counts cts <- Seurat :: GetAssayData ( seu , assay = \"RNA\" , slot = \"counts\" ) # get percentage/cell cts <- t ( cts ) / colSums ( cts ) * 100 medians <- apply ( cts , 2 , median ) # get top n genes most_expressed <- order ( medians , decreasing = T )[ ngenes : 1 ] most_exp_matrix <- as.matrix (( cts [, most_expressed ])) # prepare for plotting most_exp_df <- stack ( as.data.frame ( most_exp_matrix )) colnames ( most_exp_df ) <- c ( \"perc_total\" , \"gene\" ) # boxplot with ggplot2 boxplot <- ggplot ( most_exp_df , aes ( x = gene , y = perc_total )) + geom_boxplot () + coord_flip () return ( boxplot ) } most_expressed_boxplot ( seu , 20 ) As for most 10X based poly-A enriched single cell datasets, we find a relatively high expression of MALAT1. Many researchers choose to remove it, but it can have biological relevance (e.g. Shaat et al. 2021 ).","title":"Visualizing QC per cell and gene"},{"location":"day1/quality_control/#cell-filtering","text":"Based on the QC process we went through we can come to the following conclusions: There are no cells with very high mitochondrial gene counts. There are some cells with a hemoglobin and low ribosomal counts, and these are probably erythrocytes. There are some cells with a very low and very high number of features. These might point to non-informative cells and doublets respectively. The \u2018usual suspect\u2019 MALAT1 sometimes makes up a large part of the counts per cell. As we do not see any other suggestions of dying/stressed cells, we leave it in. In this case, a sensible decision would be to do mild filtering on the number of features per cell and mitochondrial counts. We can leave the possible erythrocytes in for now, and see where they end up later during the dimensionality reduction. In the M&M of the publication , the authors describe that they have used a threshold of < 8% mitochondrial counts and > 200 features per cell. To filter against possible doublets, here, we also filter out cells with > 5000 detected features/cell. Filtering Seurat objects can be done with the subset method for class SeuratObject : seu <- subset ( seu , subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mito < 8 ) To evaluate this did the trick we can visualize those parameters again in a violin plot: Seurat :: VlnPlot ( seu , features = c ( \"nFeature_RNA\" , \"percent.mito\" ))","title":"Cell filtering"},{"location":"day1/setup/","text":"Exercises Login and set up Choose one of the following: Enrolled: if you are enrolled in a course with a teacher Own installation: if you want to install packages on your own local Rstudio installation Docker: if you want to use the docker image locally renkulab.io if you want to easily deploy the environment outside the course Enrolled Log in to Rstudio server with the provided link and password, your username is rstudio . Own installation Install the required packages using the script install_packages.R Docker With docker, you can use exactly the same environment as we use in the enrolled course, but than running locally. In the video below there\u2019s a tutorial on how to set up a docker container for this course. Note that you will need administrator rights, and that if you are using Windows, you need the latest version of Windows 10. The command to run the environment required for this course looks like this (in a terminal): Modify the script The home directory within the container is mounted to your current directory ( $PWD ), if you want to change this behaviour, modify the path after -v to the working directory on your computer before running it. docker run \\ --rm \\ -p 8787 :8787 \\ -e PASSWORD = test \\ -v $PWD :/home/rstudio \\ geertvangeest/single-cell-rstudio:latest If this command has run successfully, approach Rstudio server like this: http://localhost:8787 Copy this URL into your browser, and you will be able to use Rstudio with all required installations. The option -v mounts a local directory in your computer to the directory /home/rstudio in the docker container (\u2018rstudio\u2019 is the default user for Rstudio containers). In that way, you have files available both in the container and on your computer. Use this directory on your computer. Change the first path to a path on your computer that you want to use as a working directory. The part geertvangeest/single-cell-rstudio:latest is the image we are going to load into the container. The image contains all the information about software and dependencies needed for this course. When you run this command for the first time it will download the image. Once it\u2019s on your computer, it will start immediately. renkulab.io To simply run the environment, you can use renku . You can find the repository (including the image) here: https://renkulab.io/projects/geert.vangeest/single-cell-training/ . Create a project Now that you have access to an environment with the required installations, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project\u2026 Continue by choosing New Directory As project type select New Project Finally, type in the project name. This should be single_cell_course . Finish by clicking Create Project . Now that we have setup a project and a project directory (it is in /home/rstudio/single_cell_course ), we can download the data that is required for this course. We will use the built-in terminal of Rstudio. To do this, select the Terminal tab: Downloading the course data To download and extract the dataset, copy-paste these commands inside the terminal tab: wget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/course_data.tar.gz tar -xvf course_data.tar.gz rm course_data.tar.gz Have a look at the data directory you have downloaded. It should contain the following: course_data \u251c\u2500\u2500 count_matrices \u2502 \u251c\u2500\u2500 ETV6-RUNX1_1 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 ETV6-RUNX1_2 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 ETV6-RUNX1_3 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 PBMMC_1 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 PBMMC_2 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u2514\u2500\u2500 PBMMC_3 \u2502 \u2514\u2500\u2500 outs \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2514\u2500\u2500 reads \u251c\u2500\u2500 ETV6-RUNX1_1_S1_L001_I1_001.fastq.gz \u251c\u2500\u2500 ETV6-RUNX1_1_S1_L001_R1_001.fastq.gz \u2514\u2500\u2500 ETV6-RUNX1_1_S1_L001_R2_001.fastq.gz 20 directories, 21 files This data comes from: Caron M, St-Onge P, Sontag T, Wang YC, Richer C, Ragoussis I, et al. Single-cell analysis of childhood leukemia reveals a link between developmental states and ribosomal protein expression as a source of intra-individual heterogeneity. Scientific Reports. 2020;10:1\u201312. Available from: http://dx.doi.org/10.1038/s41598-020-64929-x We will use the reads to showcase the use of cellranger count . The directory only reads from chromosome 21 and 22 of one sample ( ETV6-RUNX1_1 ). The count matrices are output of cellranger count , and we will use those for the other exercises in R .","title":"Setup"},{"location":"day1/setup/#exercises","text":"","title":"Exercises"},{"location":"day1/setup/#login-and-set-up","text":"Choose one of the following: Enrolled: if you are enrolled in a course with a teacher Own installation: if you want to install packages on your own local Rstudio installation Docker: if you want to use the docker image locally renkulab.io if you want to easily deploy the environment outside the course Enrolled Log in to Rstudio server with the provided link and password, your username is rstudio . Own installation Install the required packages using the script install_packages.R Docker With docker, you can use exactly the same environment as we use in the enrolled course, but than running locally. In the video below there\u2019s a tutorial on how to set up a docker container for this course. Note that you will need administrator rights, and that if you are using Windows, you need the latest version of Windows 10. The command to run the environment required for this course looks like this (in a terminal): Modify the script The home directory within the container is mounted to your current directory ( $PWD ), if you want to change this behaviour, modify the path after -v to the working directory on your computer before running it. docker run \\ --rm \\ -p 8787 :8787 \\ -e PASSWORD = test \\ -v $PWD :/home/rstudio \\ geertvangeest/single-cell-rstudio:latest If this command has run successfully, approach Rstudio server like this: http://localhost:8787 Copy this URL into your browser, and you will be able to use Rstudio with all required installations. The option -v mounts a local directory in your computer to the directory /home/rstudio in the docker container (\u2018rstudio\u2019 is the default user for Rstudio containers). In that way, you have files available both in the container and on your computer. Use this directory on your computer. Change the first path to a path on your computer that you want to use as a working directory. The part geertvangeest/single-cell-rstudio:latest is the image we are going to load into the container. The image contains all the information about software and dependencies needed for this course. When you run this command for the first time it will download the image. Once it\u2019s on your computer, it will start immediately. renkulab.io To simply run the environment, you can use renku . You can find the repository (including the image) here: https://renkulab.io/projects/geert.vangeest/single-cell-training/ .","title":"Login and set up"},{"location":"day1/setup/#create-a-project","text":"Now that you have access to an environment with the required installations, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project\u2026 Continue by choosing New Directory As project type select New Project Finally, type in the project name. This should be single_cell_course . Finish by clicking Create Project . Now that we have setup a project and a project directory (it is in /home/rstudio/single_cell_course ), we can download the data that is required for this course. We will use the built-in terminal of Rstudio. To do this, select the Terminal tab:","title":"Create a project"},{"location":"day1/setup/#downloading-the-course-data","text":"To download and extract the dataset, copy-paste these commands inside the terminal tab: wget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/course_data.tar.gz tar -xvf course_data.tar.gz rm course_data.tar.gz Have a look at the data directory you have downloaded. It should contain the following: course_data \u251c\u2500\u2500 count_matrices \u2502 \u251c\u2500\u2500 ETV6-RUNX1_1 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 ETV6-RUNX1_2 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 ETV6-RUNX1_3 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 PBMMC_1 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u251c\u2500\u2500 PBMMC_2 \u2502 \u2502 \u2514\u2500\u2500 outs \u2502 \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u2514\u2500\u2500 PBMMC_3 \u2502 \u2514\u2500\u2500 outs \u2502 \u2514\u2500\u2500 filtered_feature_bc_matrix \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2514\u2500\u2500 reads \u251c\u2500\u2500 ETV6-RUNX1_1_S1_L001_I1_001.fastq.gz \u251c\u2500\u2500 ETV6-RUNX1_1_S1_L001_R1_001.fastq.gz \u2514\u2500\u2500 ETV6-RUNX1_1_S1_L001_R2_001.fastq.gz 20 directories, 21 files This data comes from: Caron M, St-Onge P, Sontag T, Wang YC, Richer C, Ragoussis I, et al. Single-cell analysis of childhood leukemia reveals a link between developmental states and ribosomal protein expression as a source of intra-individual heterogeneity. Scientific Reports. 2020;10:1\u201312. Available from: http://dx.doi.org/10.1038/s41598-020-64929-x We will use the reads to showcase the use of cellranger count . The directory only reads from chromosome 21 and 22 of one sample ( ETV6-RUNX1_1 ). The count matrices are output of cellranger count , and we will use those for the other exercises in R .","title":"Downloading the course data"},{"location":"day2/cell_annotation/","text":"Material Download the presentation Review on automated cell annotation Exercises Load the following packages: library ( celldex ) library ( SingleR ) In the last exercise we saw that probably clustering at a resolution of 0.3 gave the most sensible results. Let\u2019s therefore set the default identity of each cell based on this clustering: seu_int <- Seurat :: SetIdent ( seu_int , value = seu_int $ integrated_snn_res.0.3 ) Note From now on, grouping (e.g. for plotting) is done by the active identity (set at @active.ident ) by default. During cell annotation we will use the original count data (not the integrated data): DefaultAssay ( seu_int ) <- \"RNA\" Based on the UMAP we have generated, we can visualize expression for a gene in each cluster: Seurat :: FeaturePlot ( seu_int , \"HBA1\" ) Based on expression of sets of genes you can do a manual cell type annotation. If you know the marker genes for some cell types, you can check whether they are up-regulated in one or the other cluster. Here we have some marker genes for two different cell types: tcell_genes <- c ( \"IL7R\" , \"LTB\" , \"TRAC\" , \"CD3D\" ) monocyte_genes <- c ( \"CD14\" , \"CST3\" , \"CD68\" , \"CTSS\" ) Let\u2019s have a look at the expression of the four T cell genes: Seurat :: FeaturePlot ( seu_int , tcell_genes , ncol = 2 ) These cells are almost all in cluster 0 and 8. Which becomes clearer when looking at the violin plot: Seurat :: VlnPlot ( seu_int , features = tcell_genes , ncol = 2 ) Exercise: Have a look at the monocyte genes as well. Which clusters contain probably monocytes? Answer Running Seurat :: FeaturePlot ( seu_int , monocyte_genes , ncol = 2 ) Returns: Corresponding mainly to cluster 2 and 9: Seurat :: VlnPlot ( seu_int , features = monocyte_genes , ncol = 2 ) We can also automate this with the function AddModuleScore . For each cell, an expression score for a group of genes is calcuated: seu_int <- Seurat :: AddModuleScore ( seu_int , features = list ( tcell_genes ), name = \"tcell_genes\" ) Exercise: After running AddModuleScore , a column was added to seu_int@meta.data . A. What is the name of that column? What kind of data is in there? B. Generate a UMAP with color accoding to this column and a violinplot grouped by cluster. Is this according to what we saw in the previous exercise? Answer A. The new column is called tcell_genes1 . It contains the module score for each cell (which is basically the average expression of the set of genes). B. You can plot the UMAP with Seurat :: FeaturePlot ( seu_int , \"tcell_genes1\" ) Returning: Seurat :: VlnPlot ( seu_int , \"tcell_genes1\" ) Which indeed shows these genes are mainly expressed in cluster 6: Annotating cells according to cycling phase Based on the same principle, we can also annotate cell cycling state. The function CellCycleScore uses AddModuleScore to get a score for the G2/M and S phase (the mitotic phases in which cell is cycling). In addition, CellCycleScore assigns each cell to either the G2/M, S or G1 phase. First we extract the built-in genes for cell cycling: s.genes <- Seurat :: cc.genes.updated.2019 $ s.genes g2m.genes <- Seurat :: cc.genes.updated.2019 $ g2m.genes Now we run the function: seu_int <- Seurat :: CellCycleScoring ( seu_int , s.features = s.genes , g2m.features = g2m.genes ) And we can visualize the annotations: Seurat :: DimPlot ( seu_int , group.by = \"Phase\" ) Based on your application, you can try to regress out the cell cycling scores at the step of scaling. Reasons for doing that could be: Merging cycling and non-cycling cells of the same type in one cluster Merging G2/M and S phase in one cluster Note Note that correcting for cell cycling is performed at the scaling step. It will therefore only influence analyses that use scaled data, like dimensionality reduction and clustering. For e.g. differential gene expression testing, we use the raw original counts (not scaled). Here, we choose not to regress out either of them. Because we are looking at developing cells, we might be interested to keep cycling cells seperated. In addition, the G2/M and S phases seem to be in the same clusters. More info on correcting for cell cycling here . Cell type annotation using SingleR To do a fully automated annoation, we need a reference dataset of primary cells. Any reference could be used. The package scRNAseq in Bioconductor includes several scRNAseq datasets that can be used as reference to SingleR . One could also use a reference made of bulk RNA seq data. Here we are using the a hematopoietic reference dataset from celldex . Check out what\u2019s in there: ref <- celldex :: NovershternHematopoieticData () class ( ref ) table ( ref $ label.main ) Note You will be asked whether to create the directory /home/rstudio/.cache/R/ExperimentHub . Type yes as a response. Note You can find more information on different reference datasets at the celldex documentation Now SingleR compares our normalized count data to a reference set, and finds the most probable annation: seu_int_SingleR <- SingleR :: SingleR ( test = Seurat :: GetAssayData ( seu_int , slot = \"data\" ), ref = ref , labels = ref $ label.main ) See what\u2019s in there by using head : head ( seu_int_SingleR ) Visualize singleR score quality scores: SingleR :: plotScoreHeatmap ( seu_int_SingleR ) SingleR :: plotDeltaDistribution ( seu_int_SingleR ) There are some annotations that contain only a few cells. They are usually not of interest, and they clogg our plots. Therefore we remove them from the annotation: singleR_labels <- seu_int_SingleR $ labels t <- table ( singleR_labels ) other <- names ( t )[ t < 10 ] singleR_labels [ singleR_labels %in% other ] <- NA In order to visualize it in our UMAP, we have to add the annotation to seu_int@meta.data : seu_int $ SingleR_annot <- singleR_labels We can plot the annotations in the UMAP. Here, we use a different package for plotting ( dittoSeq ) as it has a bit better default coloring, and some other plotting functionality we will use later on. dittoSeq :: dittoDimPlot ( seu_int , \"SingleR_annot\" , size = 0.7 ) We can check out how many cells per sample we have for each annotated cell type: dittoSeq :: dittoBarPlot ( seu_int , var = \"SingleR_annot\" , group.by = \"orig.ident\" ) Exercise: Compare our manual annotation (based on the set of T cell genes) to the annotation with SingleR . Do they correspond? Hint You can for example use the plotting function dittoBarPlot to visualize the cell types according to cluster (use integrated_snn_res.0.3 in stead of orig.ident )) Answer We can have a look at the mean module score for each SingleR annotation like this: dittoSeq :: dittoBarPlot ( seu_int , var = \"SingleR_annot\" , group.by = \"integrated_snn_res.0.3\" ) This returns: Here, you can see that cluster 0 and 8 contain cells annotated as T cells (CD4+ and CD8+). Save the dataset and clear environment Now, save the dataset so you can use it tomorrow: saveRDS ( seu_int , \"seu_int_day2_part2.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Cell annotation"},{"location":"day2/cell_annotation/#material","text":"Download the presentation Review on automated cell annotation","title":"Material"},{"location":"day2/cell_annotation/#exercises","text":"Load the following packages: library ( celldex ) library ( SingleR ) In the last exercise we saw that probably clustering at a resolution of 0.3 gave the most sensible results. Let\u2019s therefore set the default identity of each cell based on this clustering: seu_int <- Seurat :: SetIdent ( seu_int , value = seu_int $ integrated_snn_res.0.3 ) Note From now on, grouping (e.g. for plotting) is done by the active identity (set at @active.ident ) by default. During cell annotation we will use the original count data (not the integrated data): DefaultAssay ( seu_int ) <- \"RNA\" Based on the UMAP we have generated, we can visualize expression for a gene in each cluster: Seurat :: FeaturePlot ( seu_int , \"HBA1\" ) Based on expression of sets of genes you can do a manual cell type annotation. If you know the marker genes for some cell types, you can check whether they are up-regulated in one or the other cluster. Here we have some marker genes for two different cell types: tcell_genes <- c ( \"IL7R\" , \"LTB\" , \"TRAC\" , \"CD3D\" ) monocyte_genes <- c ( \"CD14\" , \"CST3\" , \"CD68\" , \"CTSS\" ) Let\u2019s have a look at the expression of the four T cell genes: Seurat :: FeaturePlot ( seu_int , tcell_genes , ncol = 2 ) These cells are almost all in cluster 0 and 8. Which becomes clearer when looking at the violin plot: Seurat :: VlnPlot ( seu_int , features = tcell_genes , ncol = 2 ) Exercise: Have a look at the monocyte genes as well. Which clusters contain probably monocytes? Answer Running Seurat :: FeaturePlot ( seu_int , monocyte_genes , ncol = 2 ) Returns: Corresponding mainly to cluster 2 and 9: Seurat :: VlnPlot ( seu_int , features = monocyte_genes , ncol = 2 ) We can also automate this with the function AddModuleScore . For each cell, an expression score for a group of genes is calcuated: seu_int <- Seurat :: AddModuleScore ( seu_int , features = list ( tcell_genes ), name = \"tcell_genes\" ) Exercise: After running AddModuleScore , a column was added to seu_int@meta.data . A. What is the name of that column? What kind of data is in there? B. Generate a UMAP with color accoding to this column and a violinplot grouped by cluster. Is this according to what we saw in the previous exercise? Answer A. The new column is called tcell_genes1 . It contains the module score for each cell (which is basically the average expression of the set of genes). B. You can plot the UMAP with Seurat :: FeaturePlot ( seu_int , \"tcell_genes1\" ) Returning: Seurat :: VlnPlot ( seu_int , \"tcell_genes1\" ) Which indeed shows these genes are mainly expressed in cluster 6:","title":"Exercises"},{"location":"day2/cell_annotation/#annotating-cells-according-to-cycling-phase","text":"Based on the same principle, we can also annotate cell cycling state. The function CellCycleScore uses AddModuleScore to get a score for the G2/M and S phase (the mitotic phases in which cell is cycling). In addition, CellCycleScore assigns each cell to either the G2/M, S or G1 phase. First we extract the built-in genes for cell cycling: s.genes <- Seurat :: cc.genes.updated.2019 $ s.genes g2m.genes <- Seurat :: cc.genes.updated.2019 $ g2m.genes Now we run the function: seu_int <- Seurat :: CellCycleScoring ( seu_int , s.features = s.genes , g2m.features = g2m.genes ) And we can visualize the annotations: Seurat :: DimPlot ( seu_int , group.by = \"Phase\" ) Based on your application, you can try to regress out the cell cycling scores at the step of scaling. Reasons for doing that could be: Merging cycling and non-cycling cells of the same type in one cluster Merging G2/M and S phase in one cluster Note Note that correcting for cell cycling is performed at the scaling step. It will therefore only influence analyses that use scaled data, like dimensionality reduction and clustering. For e.g. differential gene expression testing, we use the raw original counts (not scaled). Here, we choose not to regress out either of them. Because we are looking at developing cells, we might be interested to keep cycling cells seperated. In addition, the G2/M and S phases seem to be in the same clusters. More info on correcting for cell cycling here .","title":"Annotating cells according to cycling phase"},{"location":"day2/cell_annotation/#cell-type-annotation-using-singler","text":"To do a fully automated annoation, we need a reference dataset of primary cells. Any reference could be used. The package scRNAseq in Bioconductor includes several scRNAseq datasets that can be used as reference to SingleR . One could also use a reference made of bulk RNA seq data. Here we are using the a hematopoietic reference dataset from celldex . Check out what\u2019s in there: ref <- celldex :: NovershternHematopoieticData () class ( ref ) table ( ref $ label.main ) Note You will be asked whether to create the directory /home/rstudio/.cache/R/ExperimentHub . Type yes as a response. Note You can find more information on different reference datasets at the celldex documentation Now SingleR compares our normalized count data to a reference set, and finds the most probable annation: seu_int_SingleR <- SingleR :: SingleR ( test = Seurat :: GetAssayData ( seu_int , slot = \"data\" ), ref = ref , labels = ref $ label.main ) See what\u2019s in there by using head : head ( seu_int_SingleR ) Visualize singleR score quality scores: SingleR :: plotScoreHeatmap ( seu_int_SingleR ) SingleR :: plotDeltaDistribution ( seu_int_SingleR ) There are some annotations that contain only a few cells. They are usually not of interest, and they clogg our plots. Therefore we remove them from the annotation: singleR_labels <- seu_int_SingleR $ labels t <- table ( singleR_labels ) other <- names ( t )[ t < 10 ] singleR_labels [ singleR_labels %in% other ] <- NA In order to visualize it in our UMAP, we have to add the annotation to seu_int@meta.data : seu_int $ SingleR_annot <- singleR_labels We can plot the annotations in the UMAP. Here, we use a different package for plotting ( dittoSeq ) as it has a bit better default coloring, and some other plotting functionality we will use later on. dittoSeq :: dittoDimPlot ( seu_int , \"SingleR_annot\" , size = 0.7 ) We can check out how many cells per sample we have for each annotated cell type: dittoSeq :: dittoBarPlot ( seu_int , var = \"SingleR_annot\" , group.by = \"orig.ident\" ) Exercise: Compare our manual annotation (based on the set of T cell genes) to the annotation with SingleR . Do they correspond? Hint You can for example use the plotting function dittoBarPlot to visualize the cell types according to cluster (use integrated_snn_res.0.3 in stead of orig.ident )) Answer We can have a look at the mean module score for each SingleR annotation like this: dittoSeq :: dittoBarPlot ( seu_int , var = \"SingleR_annot\" , group.by = \"integrated_snn_res.0.3\" ) This returns: Here, you can see that cluster 0 and 8 contain cells annotated as T cells (CD4+ and CD8+).","title":"Cell type annotation using SingleR"},{"location":"day2/cell_annotation/#save-the-dataset-and-clear-environment","text":"Now, save the dataset so you can use it tomorrow: saveRDS ( seu_int , \"seu_int_day2_part2.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day2/clustering/","text":"Material Download the presentation Evaluation of clustering methods Exercises Load the seu_int dataset you have created earlier today: seu_int <- readRDS ( \"seu_int_day2_part1.rds\" ) The method implemented in Seurat first constructs a SNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset. Note We use the integrated object ( seu_int ) and the assay integrated . Unsure? Check DefaultAssay(seu_int) , and set it by DefaultAssay(seu_int) <- \"integrated\" . seu_int <- Seurat :: FindNeighbors ( seu_int , dims = 1 : 25 ) To cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the \u2018granularity\u2019 of the downstream clustering, with increased values leading to a greater number of clusters. seu_int <- Seurat :: FindClusters ( seu_int , resolution = seq ( 0.1 , 0.8 , by = 0.1 )) Cluster id of each cell is added to the metadata object, as a new column for each resolution tested: head ( seu_int @ meta.data ) To view how clusters sub-divide at increasing resolution: library ( clustree ) clustree :: clustree ( seu_int @ meta.data [, grep ( \"integrated_snn_res\" , colnames ( seu_int @ meta.data ))], prefix = \"integrated_snn_res.\" ) You can view the UMAP coloring each cell according to a cluster id like this: Seurat :: DimPlot ( seu_int , group.by = \"integrated_snn_res.0.1\" ) Exercise: Visualise clustering based on a few more resolutions. Taking the clustering and the UMAP plots into account what do you consider as a good resolution to perform the clustering? Answer Of course, there is no \u2018optimal\u2019 resolution, but based on resolution of 0.3, the tree stays relatively stable for a few resolution steps, and it seems that clustering fits the UMAP well: Seurat :: DimPlot ( seu_int , group.by = \"integrated_snn_res.0.3\" ) Exercise: When do the number of neighbors need to be changed? How does changing the method of clustering in FindClusters affect the output? Which parameter should be changed? Answer As FindClusters is an unsupervised clustering method supposedly telling yousomething about your UMAP plot, the two should go along. If one has reasons to change the number of neighbors in the UMAP function, here the same parameter should be adapted. The method can be changed with algorithm = 2,3 or 4","title":"Clustering"},{"location":"day2/clustering/#material","text":"Download the presentation Evaluation of clustering methods","title":"Material"},{"location":"day2/clustering/#exercises","text":"Load the seu_int dataset you have created earlier today: seu_int <- readRDS ( \"seu_int_day2_part1.rds\" ) The method implemented in Seurat first constructs a SNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset. Note We use the integrated object ( seu_int ) and the assay integrated . Unsure? Check DefaultAssay(seu_int) , and set it by DefaultAssay(seu_int) <- \"integrated\" . seu_int <- Seurat :: FindNeighbors ( seu_int , dims = 1 : 25 ) To cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the \u2018granularity\u2019 of the downstream clustering, with increased values leading to a greater number of clusters. seu_int <- Seurat :: FindClusters ( seu_int , resolution = seq ( 0.1 , 0.8 , by = 0.1 )) Cluster id of each cell is added to the metadata object, as a new column for each resolution tested: head ( seu_int @ meta.data ) To view how clusters sub-divide at increasing resolution: library ( clustree ) clustree :: clustree ( seu_int @ meta.data [, grep ( \"integrated_snn_res\" , colnames ( seu_int @ meta.data ))], prefix = \"integrated_snn_res.\" ) You can view the UMAP coloring each cell according to a cluster id like this: Seurat :: DimPlot ( seu_int , group.by = \"integrated_snn_res.0.1\" ) Exercise: Visualise clustering based on a few more resolutions. Taking the clustering and the UMAP plots into account what do you consider as a good resolution to perform the clustering? Answer Of course, there is no \u2018optimal\u2019 resolution, but based on resolution of 0.3, the tree stays relatively stable for a few resolution steps, and it seems that clustering fits the UMAP well: Seurat :: DimPlot ( seu_int , group.by = \"integrated_snn_res.0.3\" ) Exercise: When do the number of neighbors need to be changed? How does changing the method of clustering in FindClusters affect the output? Which parameter should be changed? Answer As FindClusters is an unsupervised clustering method supposedly telling yousomething about your UMAP plot, the two should go along. If one has reasons to change the number of neighbors in the UMAP function, here the same parameter should be adapted. The method can be changed with algorithm = 2,3 or 4","title":"Exercises"},{"location":"day2/dimensionality_reduction/","text":"Material Download the presentation Making sense of PCA Understanding t-SNE t-SNE explained by Josh Starmer Understanding UMAP Video by one of the UMAP authors More info on UMAP parameters Exercises This chapter uses the seu dataset Load the seu dataset you have created yesterday: seu <- readRDS ( \"seu_day1.rds\" ) And load the following packages: library ( Seurat ) Once the data is normalized, scaled and variable features have been identified, we can start to reduce the dimensionality of the data. For the PCA, by default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to specify a vector of genes. The PCA will only be run on the variable features, that you can check with VariableFeatures(seu) . seu <- Seurat :: RunPCA ( seu ) To view the PCA plot: Seurat :: DimPlot ( seu , reduction = \"pca\" ) We can colour the PCA plot according to any factor that is present in @meta.data , or for any gene. For example we can take the column percent.globin : Seurat :: FeaturePlot ( seu , reduction = \"pca\" , features = \"percent.globin\" ) Note Note that we used a different plotting function here: FeaturePlot . The difference between DimPlot and FeaturePlot is that the first allows you to color the points in the plot according to a grouping variable (e.g. sample) while the latter allows you to color the points according to a continuous variable (e.g. gene expression). Exercise: Generate a PCA plot where color is according to counts of a gene (i.e. gene expression). For example, you can take HBA1 (alpha subunit of hemoglobin), or one of the most variable genes (e.g. IGKC ). Answer Generating a PCA plot coloured according to gene expression (here HBA1 ): Seurat :: FeaturePlot ( seu , reduction = \"pca\" , features = \"HBA1\" ) We can generate heatmaps according to the correlations with the different dimensions of our PCA: Seurat :: DimHeatmap ( seu , dims = 1 : 12 , cells = 500 , balanced = TRUE ) The elbowplot can help you in determining how many PCs to use for downstream analysis such as UMAP: Seurat :: ElbowPlot ( seu , ndims = 40 ) The elbow plot ranks principle components based on the percentage of variance explained by each one. Where we observe an \u201celbow\u201d or flattening curve, the majority of true signal is captured by this number of PCs, eg around 25 PCs for the seu dataset. Including too many PCs usually does not affect much the result, while including too few PCs can affect the results very much. UMAP: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. seu <- Seurat :: RunUMAP ( seu , dims = 1 : 25 ) To view the UMAP plot: Seurat :: DimPlot ( seu , reduction = \"umap\" ) Exercise: Try to change: A. Color the dots in the UMAP according to a variable (e.g. percent.globin or HBA1 ). Any idea where the erythrocytes probably are in the UMAP? B. The number of neighbors used for the calculation of the UMAP. Which is the parameter to change and how did it affect the output. What is the default ? In which situation would you lower/increase this ? C. The number of dims to extremes dims = 1:5 or dims = 1:50 how did it affect the output ? In your opinion better few PCAs too much or too few ? Why does dims = 1:100 not work? When would more precision be needed? Answer Answer A Seurat :: FeaturePlot ( seu , features = c ( \"HBA1\" , \"percent.globin\" , \"IGKC\" , \"percent.mito\" )) The erythrocytes are probably in the cluster with a higher percentage of globin expression. Answer B seu <- Seurat :: RunUMAP ( seu , dims = 1 : 25 , n.neighbors = 5 ) Seurat :: DimPlot ( seu , reduction = \"umap\" ) The default number of neighbours is 30. It can be of interest to change the number of neighbors if one has subset the data (for instance in the situation where you would only consider the t-cells inyour data set), then maybe the number of neighbors in a cluster would anyway be most of the time lower than 30 then 30 is too much. In the other extreme where your dataset is extremely big an increase in the number of neighbors can be considered. Answer C seu <- Seurat :: RunUMAP ( seu , dims = 1 : 5 ) Seurat :: DimPlot ( seu , reduction = \"umap\" ) seu <- Seurat :: RunUMAP ( seu , dims = 1 : 50 ) Seurat :: DimPlot ( seu , reduction = \"umap\" ) Taking dims = 1:100 does not work as in the step RunPCA by default only 50pcs are calculated, so the maximum that we can consider in further steps are 50, if more precision makes sense, for instance, if the genes that is of interest for your study is not present when the RunPCA was calculated, then an increase in the number of components calculated at start might be interesting tobe considered. Taking too few PCs we have a \u00ab blob \u00bb everything looks connected. Too many PCs tends to separate everything. Personally it is more interesting for me too have maybe 2 clusters separated of epithelial cells that I then group for further downstream analysis rather than having very distinct cells being clustered together. So I would rather take the \u00ab elbow \u00bb of the elbow plot a bit further to the right. Warning After having done these exercises, change the UMAP back to a UMAP based on the first 25 PCs, in order to replicate the exercises in the following chapters. Do this by: seu <- Seurat :: RunUMAP ( seu , dims = 1 : 25 )","title":"Dimensionality reduction"},{"location":"day2/dimensionality_reduction/#material","text":"Download the presentation Making sense of PCA Understanding t-SNE t-SNE explained by Josh Starmer Understanding UMAP Video by one of the UMAP authors More info on UMAP parameters","title":"Material"},{"location":"day2/dimensionality_reduction/#exercises","text":"This chapter uses the seu dataset Load the seu dataset you have created yesterday: seu <- readRDS ( \"seu_day1.rds\" ) And load the following packages: library ( Seurat ) Once the data is normalized, scaled and variable features have been identified, we can start to reduce the dimensionality of the data. For the PCA, by default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to specify a vector of genes. The PCA will only be run on the variable features, that you can check with VariableFeatures(seu) . seu <- Seurat :: RunPCA ( seu ) To view the PCA plot: Seurat :: DimPlot ( seu , reduction = \"pca\" ) We can colour the PCA plot according to any factor that is present in @meta.data , or for any gene. For example we can take the column percent.globin : Seurat :: FeaturePlot ( seu , reduction = \"pca\" , features = \"percent.globin\" ) Note Note that we used a different plotting function here: FeaturePlot . The difference between DimPlot and FeaturePlot is that the first allows you to color the points in the plot according to a grouping variable (e.g. sample) while the latter allows you to color the points according to a continuous variable (e.g. gene expression). Exercise: Generate a PCA plot where color is according to counts of a gene (i.e. gene expression). For example, you can take HBA1 (alpha subunit of hemoglobin), or one of the most variable genes (e.g. IGKC ). Answer Generating a PCA plot coloured according to gene expression (here HBA1 ): Seurat :: FeaturePlot ( seu , reduction = \"pca\" , features = \"HBA1\" ) We can generate heatmaps according to the correlations with the different dimensions of our PCA: Seurat :: DimHeatmap ( seu , dims = 1 : 12 , cells = 500 , balanced = TRUE ) The elbowplot can help you in determining how many PCs to use for downstream analysis such as UMAP: Seurat :: ElbowPlot ( seu , ndims = 40 ) The elbow plot ranks principle components based on the percentage of variance explained by each one. Where we observe an \u201celbow\u201d or flattening curve, the majority of true signal is captured by this number of PCs, eg around 25 PCs for the seu dataset. Including too many PCs usually does not affect much the result, while including too few PCs can affect the results very much. UMAP: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. seu <- Seurat :: RunUMAP ( seu , dims = 1 : 25 ) To view the UMAP plot: Seurat :: DimPlot ( seu , reduction = \"umap\" ) Exercise: Try to change: A. Color the dots in the UMAP according to a variable (e.g. percent.globin or HBA1 ). Any idea where the erythrocytes probably are in the UMAP? B. The number of neighbors used for the calculation of the UMAP. Which is the parameter to change and how did it affect the output. What is the default ? In which situation would you lower/increase this ? C. The number of dims to extremes dims = 1:5 or dims = 1:50 how did it affect the output ? In your opinion better few PCAs too much or too few ? Why does dims = 1:100 not work? When would more precision be needed? Answer Answer A Seurat :: FeaturePlot ( seu , features = c ( \"HBA1\" , \"percent.globin\" , \"IGKC\" , \"percent.mito\" )) The erythrocytes are probably in the cluster with a higher percentage of globin expression. Answer B seu <- Seurat :: RunUMAP ( seu , dims = 1 : 25 , n.neighbors = 5 ) Seurat :: DimPlot ( seu , reduction = \"umap\" ) The default number of neighbours is 30. It can be of interest to change the number of neighbors if one has subset the data (for instance in the situation where you would only consider the t-cells inyour data set), then maybe the number of neighbors in a cluster would anyway be most of the time lower than 30 then 30 is too much. In the other extreme where your dataset is extremely big an increase in the number of neighbors can be considered. Answer C seu <- Seurat :: RunUMAP ( seu , dims = 1 : 5 ) Seurat :: DimPlot ( seu , reduction = \"umap\" ) seu <- Seurat :: RunUMAP ( seu , dims = 1 : 50 ) Seurat :: DimPlot ( seu , reduction = \"umap\" ) Taking dims = 1:100 does not work as in the step RunPCA by default only 50pcs are calculated, so the maximum that we can consider in further steps are 50, if more precision makes sense, for instance, if the genes that is of interest for your study is not present when the RunPCA was calculated, then an increase in the number of components calculated at start might be interesting tobe considered. Taking too few PCs we have a \u00ab blob \u00bb everything looks connected. Too many PCs tends to separate everything. Personally it is more interesting for me too have maybe 2 clusters separated of epithelial cells that I then group for further downstream analysis rather than having very distinct cells being clustered together. So I would rather take the \u00ab elbow \u00bb of the elbow plot a bit further to the right. Warning After having done these exercises, change the UMAP back to a UMAP based on the first 25 PCs, in order to replicate the exercises in the following chapters. Do this by: seu <- Seurat :: RunUMAP ( seu , dims = 1 : 25 )","title":"Exercises"},{"location":"day2/integration/","text":"Material Download the presentation Exercises Let\u2019s have a look at the UMAP again. Although cells of different samples are shared amongst \u2018clusters\u2019, you can still see seperation within the clusters: Seurat :: DimPlot ( seu , reduction = \"umap\" ) To perform the integration, we split our object by sample, resulting into a list with each sample as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation ( \"vst\" ). seu_list <- Seurat :: SplitObject ( seu , split.by = \"orig.ident\" ) for ( i in 1 : length ( seu_list )) { seu_list [[ i ]] <- Seurat :: NormalizeData ( seu_list [[ i ]]) seu_list [[ i ]] <- Seurat :: FindVariableFeatures ( seu_list [[ i ]], selection.method = \"vst\" , nfeatures = 2000 , verbose = FALSE ) } After this, we prepare the integration by selecting integration anchors: seu_anchors <- Seurat :: FindIntegrationAnchors ( object.list = seu_list , dims = 1 : 30 ) And finally perform the integration: seu_int <- Seurat :: IntegrateData ( anchorset = seu_anchors , dims = 1 : 30 ) After running IntegrateData , the Seurat object will contain an additional element of class Assay with the integrated (or \u2018batch-corrected\u2019) expression matrix. This new Assay is called integrated , and exists next to the already existing RNA element with class Assay . Warning Use the Assay integrated only for clustering and visualisation. It will give unexpected results during e.g. differential gene expression analysis. Therefore, use the RNA element for other analyses. We can then use this new integrated matrix for clustering and visualization. Now, we can scale the integrated data, run PCA, and visualize the results with UMAP. Note No need to re-run FindVariableFeatures , these were automatically set by calling IntegrateData . First, switch the default Assay to integrated (in stead of RNA ). Seurat :: DefaultAssay ( seu_int ) <- \"integrated\" Exercise: In order to redo the clustering, scale the integrated data, run the PCA and the UMAP again (using the function ScaleData , RunPCA and RunUMAP ). After that, generate the UMAP plot. Did the integration perform well? Answer Performing the scaling, PCA and UMAP: seu_int <- Seurat :: ScaleData ( seu_int ) seu_int <- Seurat :: RunPCA ( seu_int , npcs = 30 ) seu_int <- Seurat :: RunUMAP ( seu_int , reduction = \"pca\" , dims = 1 : 30 ) Plotting the UMAP: Seurat :: DimPlot ( seu_int , reduction = \"umap\" ) Returning: Save the dataset and clear environment Finally, store the integrated dataset as an .rds file. We will use it tomorrow: saveRDS ( seu_int , \"seu_int_day2_part1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Integration"},{"location":"day2/integration/#material","text":"Download the presentation","title":"Material"},{"location":"day2/integration/#exercises","text":"Let\u2019s have a look at the UMAP again. Although cells of different samples are shared amongst \u2018clusters\u2019, you can still see seperation within the clusters: Seurat :: DimPlot ( seu , reduction = \"umap\" ) To perform the integration, we split our object by sample, resulting into a list with each sample as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation ( \"vst\" ). seu_list <- Seurat :: SplitObject ( seu , split.by = \"orig.ident\" ) for ( i in 1 : length ( seu_list )) { seu_list [[ i ]] <- Seurat :: NormalizeData ( seu_list [[ i ]]) seu_list [[ i ]] <- Seurat :: FindVariableFeatures ( seu_list [[ i ]], selection.method = \"vst\" , nfeatures = 2000 , verbose = FALSE ) } After this, we prepare the integration by selecting integration anchors: seu_anchors <- Seurat :: FindIntegrationAnchors ( object.list = seu_list , dims = 1 : 30 ) And finally perform the integration: seu_int <- Seurat :: IntegrateData ( anchorset = seu_anchors , dims = 1 : 30 ) After running IntegrateData , the Seurat object will contain an additional element of class Assay with the integrated (or \u2018batch-corrected\u2019) expression matrix. This new Assay is called integrated , and exists next to the already existing RNA element with class Assay . Warning Use the Assay integrated only for clustering and visualisation. It will give unexpected results during e.g. differential gene expression analysis. Therefore, use the RNA element for other analyses. We can then use this new integrated matrix for clustering and visualization. Now, we can scale the integrated data, run PCA, and visualize the results with UMAP. Note No need to re-run FindVariableFeatures , these were automatically set by calling IntegrateData . First, switch the default Assay to integrated (in stead of RNA ). Seurat :: DefaultAssay ( seu_int ) <- \"integrated\" Exercise: In order to redo the clustering, scale the integrated data, run the PCA and the UMAP again (using the function ScaleData , RunPCA and RunUMAP ). After that, generate the UMAP plot. Did the integration perform well? Answer Performing the scaling, PCA and UMAP: seu_int <- Seurat :: ScaleData ( seu_int ) seu_int <- Seurat :: RunPCA ( seu_int , npcs = 30 ) seu_int <- Seurat :: RunUMAP ( seu_int , reduction = \"pca\" , dims = 1 : 30 ) Plotting the UMAP: Seurat :: DimPlot ( seu_int , reduction = \"umap\" ) Returning:","title":"Exercises"},{"location":"day2/integration/#save-the-dataset-and-clear-environment","text":"Finally, store the integrated dataset as an .rds file. We will use it tomorrow: saveRDS ( seu_int , \"seu_int_day2_part1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day3/differential_gene_expression/","text":"Material Download the presentation More information on pseudobulk analysis Muscat for pseudobulk DGE. Paper on the robustness of different differential expression analysis methods Exercises Find all markers for each cluster Load the seu_int dataset you have created yesterday: seu_int <- readRDS ( \"seu_int_day2_part2.rds\" ) And load the following packages: library ( Seurat ) library ( edgeR ) library ( limma ) The function FindAllMarkers performs a Wilcoxon plot to determine the genes differentially expressed between each cluster and the rest of the cells. Other types of tests than the Wilcoxon test are available. Check it out by running ?Seurat::FindAllMarkers . Now run analysis: de_genes <- Seurat :: FindAllMarkers ( seu_int , min.pct = 0.25 , only.pos = TRUE ) Time for coffee This takes a while. Have a break. We can extract the top 3 markers per cluster: library ( dplyr ) top_specific_markers <- de_genes %>% group_by ( cluster ) %>% top_n ( 3 , avg_log2FC ) And generate e.g. a dotplot: dittoSeq :: dittoDotPlot ( seu_int , vars = unique ( top_specific_markers $ gene ), group.by = \"integrated_snn_res.0.3\" ) Exercise: What are significant marker genes in cluster 0 and 8? Are the T cell genes in there? Hint You can re-load the vector with immune genes with: tcell_genes <- c ( \"IL7R\" , \"LTB\" , \"TRAC\" , \"CD3D\" ) Answer Running de_genes [ de_genes $ gene %in% tcell_genes ,] Returns: p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene CD3D 0.000000e+00 2.0432771 0.768 0.228 0.000000e+00 0 CD3D TRAC 1.157793e-287 1.6805543 0.618 0.205 2.161947e-283 0 TRAC LTB 1.072643e-266 1.5215326 0.757 0.395 2.002946e-262 0 LTB IL7R 5.112493e-211 1.5236657 0.438 0.114 9.546557e-207 0 IL7R LTB.7 6.554548e-36 1.1405474 0.672 0.465 1.223931e-31 7 LTB TRAC.8 7.568418e-117 1.8472689 0.759 0.273 1.413251e-112 8 TRAC CD3D.8 3.079377e-110 1.7144870 0.800 0.326 5.750121e-106 8 CD3D LTB.8 1.580808e-61 1.6529117 0.774 0.461 2.951843e-57 8 LTB IL7R.2 4.497526e-45 1.1489439 0.458 0.173 8.398231e-41 8 IL7R LTB.11 2.727014e-25 0.8193337 0.750 0.467 5.092153e-21 11 LTB So, yes, the t-cell genes are highly significant markers for cluster 0 and 8. Differential expression between groups of cells The FindMarkers function allows to test for differential gene expression analysis specifically between 2 groups of cells, i.e. perform pairwise comparisons, eg between cells of cluster 0 vs cluster 2, or between cells annotated as T-cells and B-cells. First we can set the default cell identity to the cell types defined by SingleR : seu_int <- Seurat :: SetIdent ( seu_int , value = \"SingleR_annot\" ) Run the differential gene expression analysis: deg_cd8_cd4 <- Seurat :: FindMarkers ( seu_int , ident.1 = \"CD8+ T cells\" , ident.2 = \"CD4+ T cells\" , group.by = seu_int $ SingleR_annot , test.use = \"wilcox\" ) Exercise: Are CD8A, CD8B and CD4 in there? What does the sign (i.e. positive or negative) mean in the log fold change values? Are they according to the CD8+ and CD4+ annotations? Check your answer by generating a violin plot of a top differentially expressed gene. Answer You can check out the results with: View ( deg_cd8_cd4 ) For an explanation of the log fold change have a look at ?Seurat::FindMarkers . At Value it says: avg_logFC : log fold-chage of the average expression between the two groups. Positive values indicate that the gene is more highly expressed in the first group To view CD8A, CD8B and CD4: deg_cd8_cd4 [ c ( \"CD4\" , \"CD8A\" , \"CD8B\" ),] Returning: p_val avg_log2FC pct.1 pct.2 p_val_adj CD4 1.070126e-13 -0.4000835 0.012 0.103 1.998246e-09 CD8A 1.409306e-77 1.2956354 0.344 0.008 2.631597e-73 CD8B 7.113148e-36 0.8536693 0.479 0.177 1.328238e-31 Indeed, a negative log2FC for CD4 meaning a lower expression in CD8+ T-cells, and a positive log2FC for CD8A and CD8B, meaning a higher expression in CD8+ T-cells. Plotting the the genes in the T cells: Seurat :: VlnPlot ( seu_int , features = c ( \"CD4\" , \"CD8A\" , \"CD8B\" ), idents = c ( \"CD8+ T cells\" , \"CD4+ T cells\" )) Returning: Differential expression using limma The Wilcoxon test implemented in FindMarkers does not allow to test for complex design (eg factorial experiments) or to include batch as a covariate. We can use edgeR or limma which are designed for microarray or bulk RNA seq data and provide a design matrix that includes covariates for example. We will go back to the pancreas cells sequenced with different technologies, analyze differentially expressed genes between 2 clusters of cells using the technologies as covariates. Similar approaches can be used to analyze differentially expressed genes between conditions, eg sick vs healthy, wild type versus knockout, etc, and including batches in the model if they are present. We will load an objects containing only pro B cells, both from the healthy tissues, and malignant tissues. We can load it like this: proB <- readRDS ( \"proB.rds\" ) Since we will start wit differential gene expression, we set the default assay back to \u201cRNA\u201d. Also, we set the default identity to the cell type: Seurat :: DefaultAssay ( proB ) <- \"RNA\" Seurat :: Idents ( proB ) <- proB $ orig.ident Let\u2019s have a look at the UMAP (again), coloured by celltype: Seurat :: DimPlot ( proB ) Let\u2019s say we are specifically interested to test for differential gene expression between the tumor and normal samples. Note Here we could also test for e.g. healthy versus diseased within a celltype/cluster. Now we will run differential expression analysis between cell type delta and gamma using the technology as a covariate by using limma . Get the count matrix and keep only genes that are expressed in at least one cell: counts <- Seurat :: GetAssayData ( proB , slot = \"counts\" ) counts <- counts [ rowSums ( counts ) != 0 ,] Generate a DGEList object to use as input for limma : dge <- edgeR :: DGEList ( counts = counts ) dge <- edgeR :: calcNormFactors ( dge ) Generate a design matrix: design <- model.matrix ( ~ 0 + type , data = proB @ meta.data ) colnames ( design ) <- make.names ( c ( \"ETV6-RUNX1\" , \"PBMMC\" )) Specify which contrasts to check: contrast.mat <- limma :: makeContrasts ( ETV6.RUNX1 - PBMMC , levels = design ) Now limma can perform the transformation with voom , fit the model, compute the contrasts and compute test statistics with eBayes : vm <- limma :: voom ( dge , design = design , plot = TRUE ) fit <- limma :: lmFit ( vm , design = design ) fit.contrasts <- limma :: contrasts.fit ( fit , contrast.mat ) fit.contrasts <- limma :: eBayes ( fit.contrasts ) We can use topTable to get the most significantly differentially expressed genes: limma :: topTable ( fit.contrasts , number = 10 , sort.by = \"P\" ) And we can check whether this corresponds to the counts by generating a violin plot: Seurat :: VlnPlot ( proB , \"CD52\" , split.by = \"tech\" ) Seurat :: VlnPlot ( proB , \"IGLL1\" , split.by = \"tech\" ) We can run a similar analysis with Seurat . Run the code below. We will use the output object for the enrichment analysis. tum_vs_norm <- Seurat :: FindMarkers ( proB , ident.1 = \"ETV6-RUNX1\" , ident.2 = \"PBMMC\" , group.by = \"type\" )","title":"Differential gene expression"},{"location":"day3/differential_gene_expression/#material","text":"Download the presentation More information on pseudobulk analysis Muscat for pseudobulk DGE. Paper on the robustness of different differential expression analysis methods","title":"Material"},{"location":"day3/differential_gene_expression/#exercises","text":"","title":"Exercises"},{"location":"day3/differential_gene_expression/#find-all-markers-for-each-cluster","text":"Load the seu_int dataset you have created yesterday: seu_int <- readRDS ( \"seu_int_day2_part2.rds\" ) And load the following packages: library ( Seurat ) library ( edgeR ) library ( limma ) The function FindAllMarkers performs a Wilcoxon plot to determine the genes differentially expressed between each cluster and the rest of the cells. Other types of tests than the Wilcoxon test are available. Check it out by running ?Seurat::FindAllMarkers . Now run analysis: de_genes <- Seurat :: FindAllMarkers ( seu_int , min.pct = 0.25 , only.pos = TRUE ) Time for coffee This takes a while. Have a break. We can extract the top 3 markers per cluster: library ( dplyr ) top_specific_markers <- de_genes %>% group_by ( cluster ) %>% top_n ( 3 , avg_log2FC ) And generate e.g. a dotplot: dittoSeq :: dittoDotPlot ( seu_int , vars = unique ( top_specific_markers $ gene ), group.by = \"integrated_snn_res.0.3\" ) Exercise: What are significant marker genes in cluster 0 and 8? Are the T cell genes in there? Hint You can re-load the vector with immune genes with: tcell_genes <- c ( \"IL7R\" , \"LTB\" , \"TRAC\" , \"CD3D\" ) Answer Running de_genes [ de_genes $ gene %in% tcell_genes ,] Returns: p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene CD3D 0.000000e+00 2.0432771 0.768 0.228 0.000000e+00 0 CD3D TRAC 1.157793e-287 1.6805543 0.618 0.205 2.161947e-283 0 TRAC LTB 1.072643e-266 1.5215326 0.757 0.395 2.002946e-262 0 LTB IL7R 5.112493e-211 1.5236657 0.438 0.114 9.546557e-207 0 IL7R LTB.7 6.554548e-36 1.1405474 0.672 0.465 1.223931e-31 7 LTB TRAC.8 7.568418e-117 1.8472689 0.759 0.273 1.413251e-112 8 TRAC CD3D.8 3.079377e-110 1.7144870 0.800 0.326 5.750121e-106 8 CD3D LTB.8 1.580808e-61 1.6529117 0.774 0.461 2.951843e-57 8 LTB IL7R.2 4.497526e-45 1.1489439 0.458 0.173 8.398231e-41 8 IL7R LTB.11 2.727014e-25 0.8193337 0.750 0.467 5.092153e-21 11 LTB So, yes, the t-cell genes are highly significant markers for cluster 0 and 8.","title":"Find all markers for each cluster"},{"location":"day3/differential_gene_expression/#differential-expression-between-groups-of-cells","text":"The FindMarkers function allows to test for differential gene expression analysis specifically between 2 groups of cells, i.e. perform pairwise comparisons, eg between cells of cluster 0 vs cluster 2, or between cells annotated as T-cells and B-cells. First we can set the default cell identity to the cell types defined by SingleR : seu_int <- Seurat :: SetIdent ( seu_int , value = \"SingleR_annot\" ) Run the differential gene expression analysis: deg_cd8_cd4 <- Seurat :: FindMarkers ( seu_int , ident.1 = \"CD8+ T cells\" , ident.2 = \"CD4+ T cells\" , group.by = seu_int $ SingleR_annot , test.use = \"wilcox\" ) Exercise: Are CD8A, CD8B and CD4 in there? What does the sign (i.e. positive or negative) mean in the log fold change values? Are they according to the CD8+ and CD4+ annotations? Check your answer by generating a violin plot of a top differentially expressed gene. Answer You can check out the results with: View ( deg_cd8_cd4 ) For an explanation of the log fold change have a look at ?Seurat::FindMarkers . At Value it says: avg_logFC : log fold-chage of the average expression between the two groups. Positive values indicate that the gene is more highly expressed in the first group To view CD8A, CD8B and CD4: deg_cd8_cd4 [ c ( \"CD4\" , \"CD8A\" , \"CD8B\" ),] Returning: p_val avg_log2FC pct.1 pct.2 p_val_adj CD4 1.070126e-13 -0.4000835 0.012 0.103 1.998246e-09 CD8A 1.409306e-77 1.2956354 0.344 0.008 2.631597e-73 CD8B 7.113148e-36 0.8536693 0.479 0.177 1.328238e-31 Indeed, a negative log2FC for CD4 meaning a lower expression in CD8+ T-cells, and a positive log2FC for CD8A and CD8B, meaning a higher expression in CD8+ T-cells. Plotting the the genes in the T cells: Seurat :: VlnPlot ( seu_int , features = c ( \"CD4\" , \"CD8A\" , \"CD8B\" ), idents = c ( \"CD8+ T cells\" , \"CD4+ T cells\" )) Returning:","title":"Differential expression between groups of cells"},{"location":"day3/differential_gene_expression/#differential-expression-using-limma","text":"The Wilcoxon test implemented in FindMarkers does not allow to test for complex design (eg factorial experiments) or to include batch as a covariate. We can use edgeR or limma which are designed for microarray or bulk RNA seq data and provide a design matrix that includes covariates for example. We will go back to the pancreas cells sequenced with different technologies, analyze differentially expressed genes between 2 clusters of cells using the technologies as covariates. Similar approaches can be used to analyze differentially expressed genes between conditions, eg sick vs healthy, wild type versus knockout, etc, and including batches in the model if they are present. We will load an objects containing only pro B cells, both from the healthy tissues, and malignant tissues. We can load it like this: proB <- readRDS ( \"proB.rds\" ) Since we will start wit differential gene expression, we set the default assay back to \u201cRNA\u201d. Also, we set the default identity to the cell type: Seurat :: DefaultAssay ( proB ) <- \"RNA\" Seurat :: Idents ( proB ) <- proB $ orig.ident Let\u2019s have a look at the UMAP (again), coloured by celltype: Seurat :: DimPlot ( proB ) Let\u2019s say we are specifically interested to test for differential gene expression between the tumor and normal samples. Note Here we could also test for e.g. healthy versus diseased within a celltype/cluster. Now we will run differential expression analysis between cell type delta and gamma using the technology as a covariate by using limma . Get the count matrix and keep only genes that are expressed in at least one cell: counts <- Seurat :: GetAssayData ( proB , slot = \"counts\" ) counts <- counts [ rowSums ( counts ) != 0 ,] Generate a DGEList object to use as input for limma : dge <- edgeR :: DGEList ( counts = counts ) dge <- edgeR :: calcNormFactors ( dge ) Generate a design matrix: design <- model.matrix ( ~ 0 + type , data = proB @ meta.data ) colnames ( design ) <- make.names ( c ( \"ETV6-RUNX1\" , \"PBMMC\" )) Specify which contrasts to check: contrast.mat <- limma :: makeContrasts ( ETV6.RUNX1 - PBMMC , levels = design ) Now limma can perform the transformation with voom , fit the model, compute the contrasts and compute test statistics with eBayes : vm <- limma :: voom ( dge , design = design , plot = TRUE ) fit <- limma :: lmFit ( vm , design = design ) fit.contrasts <- limma :: contrasts.fit ( fit , contrast.mat ) fit.contrasts <- limma :: eBayes ( fit.contrasts ) We can use topTable to get the most significantly differentially expressed genes: limma :: topTable ( fit.contrasts , number = 10 , sort.by = \"P\" ) And we can check whether this corresponds to the counts by generating a violin plot: Seurat :: VlnPlot ( proB , \"CD52\" , split.by = \"tech\" ) Seurat :: VlnPlot ( proB , \"IGLL1\" , split.by = \"tech\" ) We can run a similar analysis with Seurat . Run the code below. We will use the output object for the enrichment analysis. tum_vs_norm <- Seurat :: FindMarkers ( proB , ident.1 = \"ETV6-RUNX1\" , ident.2 = \"PBMMC\" , group.by = \"type\" )","title":"Differential expression using limma"},{"location":"day3/enrichment_analysis/","text":"Material MSigDB clusterProfiler vignette Revigo Signaling Pathway Impact Analysis (SPIA) Original paper on GSEA STRING for protein-protein interactions GO figure! for plotting GO terms and the associated paper Exercises Load the following packages: library ( clusterProfiler ) library ( enrichplot ) If the FindMarkers or FindAllMarkers functions were used, we have a table containing only the significant genes, but we don\u2019t have any information for the non-significant genes. Therefore, we can use the over-representation analysis which is a threshold-based method. Using our list of significant genes, we can test if any gene set is over-represented in our data or not using a test similar to a Fisher test to compare differences in proportions. The clusterProfiler package provides functions for over-representation analysis of Gene Ontology gene sets (among other functions) or KEGG gene sets. Genes can be labeled using different types of labels, eg symbol, ensembl ID, Entrez ID. To list the allowed label types use: BiocManager :: install ( \"org.Hs.eg.db\" , update = FALSE ) library ( org.Hs.eg.db ) AnnotationDbi :: keytypes ( org.Hs.eg.db ) Let\u2019s select a set of genes that are upregulated in the astrocytes compared to the macrophages: tum_down <- subset ( tum_vs_norm , tum_vs_norm $ avg_log2FC < -1 & tum_vs_norm $ p_val_adj < 0.05 ) tum_down_genes <- rownames ( tum_down ) We can do a gene ontology term enrichment analysis based on this set of genes: tum_vs_norm_go <- clusterProfiler :: enrichGO ( tum_down_genes , \"org.Hs.eg.db\" , keyType = \"SYMBOL\" , ont = \"BP\" , minGSSize = 50 ) The results are stored in the @result slot: enr_go <- clusterProfiler :: simplify ( tum_vs_norm_go ) View ( enr_go @ result ) We can quite easily generate an enrichment map with the enrichplot package: enrichplot :: emapplot ( enrichplot :: pairwise_termsim ( enr_go ), showCategory = 30 , cex_label_category = 0.5 ) In stead of testing for gene ontology terms, we can also test for other gene set collections. For example the hallmark collection from MSigDB : gmt <- msigdbr :: msigdbr ( species = \"human\" , category = \"H\" ) We can use the function enricher to test for enrichment of any set of genes. But we would have to test it against a \u201cuniverse\u201d, i.e. the background genes: tum_vs_norm_enrich <- clusterProfiler :: enricher ( gene = tum_down_genes , universe = rownames ( proB ), pAdjustMethod = \"BH\" , pvalueCutoff = 0.05 , qvalueCutoff = 0.05 , TERM2GENE = gmt [, c ( \"gs_name\" , \"gene_symbol\" )]) The most signifcantly enriched group of genes is HALLMARK_G2M_CHECKPOINT : View ( tum_vs_norm_enrich @ result )","title":"Enrichment analysis"},{"location":"day3/enrichment_analysis/#material","text":"MSigDB clusterProfiler vignette Revigo Signaling Pathway Impact Analysis (SPIA) Original paper on GSEA STRING for protein-protein interactions GO figure! for plotting GO terms and the associated paper","title":"Material"},{"location":"day3/enrichment_analysis/#exercises","text":"Load the following packages: library ( clusterProfiler ) library ( enrichplot ) If the FindMarkers or FindAllMarkers functions were used, we have a table containing only the significant genes, but we don\u2019t have any information for the non-significant genes. Therefore, we can use the over-representation analysis which is a threshold-based method. Using our list of significant genes, we can test if any gene set is over-represented in our data or not using a test similar to a Fisher test to compare differences in proportions. The clusterProfiler package provides functions for over-representation analysis of Gene Ontology gene sets (among other functions) or KEGG gene sets. Genes can be labeled using different types of labels, eg symbol, ensembl ID, Entrez ID. To list the allowed label types use: BiocManager :: install ( \"org.Hs.eg.db\" , update = FALSE ) library ( org.Hs.eg.db ) AnnotationDbi :: keytypes ( org.Hs.eg.db ) Let\u2019s select a set of genes that are upregulated in the astrocytes compared to the macrophages: tum_down <- subset ( tum_vs_norm , tum_vs_norm $ avg_log2FC < -1 & tum_vs_norm $ p_val_adj < 0.05 ) tum_down_genes <- rownames ( tum_down ) We can do a gene ontology term enrichment analysis based on this set of genes: tum_vs_norm_go <- clusterProfiler :: enrichGO ( tum_down_genes , \"org.Hs.eg.db\" , keyType = \"SYMBOL\" , ont = \"BP\" , minGSSize = 50 ) The results are stored in the @result slot: enr_go <- clusterProfiler :: simplify ( tum_vs_norm_go ) View ( enr_go @ result ) We can quite easily generate an enrichment map with the enrichplot package: enrichplot :: emapplot ( enrichplot :: pairwise_termsim ( enr_go ), showCategory = 30 , cex_label_category = 0.5 ) In stead of testing for gene ontology terms, we can also test for other gene set collections. For example the hallmark collection from MSigDB : gmt <- msigdbr :: msigdbr ( species = \"human\" , category = \"H\" ) We can use the function enricher to test for enrichment of any set of genes. But we would have to test it against a \u201cuniverse\u201d, i.e. the background genes: tum_vs_norm_enrich <- clusterProfiler :: enricher ( gene = tum_down_genes , universe = rownames ( proB ), pAdjustMethod = \"BH\" , pvalueCutoff = 0.05 , qvalueCutoff = 0.05 , TERM2GENE = gmt [, c ( \"gs_name\" , \"gene_symbol\" )]) The most signifcantly enriched group of genes is HALLMARK_G2M_CHECKPOINT : View ( tum_vs_norm_enrich @ result )","title":"Exercises"},{"location":"day3/trajectory_analysis/","text":"Material Download the presentation slingshot vignette monocle3 Exercises Load the following packages: library ( SingleCellExperiment ) library ( scater ) library ( slingshot ) library ( ggplot2 ) library ( ggbeeswarm ) Trajectory analysis using Slingshot This part uses the Deng dataset Read in data. It is an object of class SingleCellExperiment . deng_SCE <- readRDS ( \"data/deng_dataset/deng-reads.rds\" ) Perform the first steps of the analysis. The deng_SCE object contains cells that were isolated at different stages of mouse embryogenesis, from the zygote stage to the late blastula. The levels of the cell type are in alphabetical order. We now change the level order for plotting in developmental order: deng_SCE $ cell_type2 <- factor ( deng_SCE $ cell_type2 , levels = c ( \"zy\" , \"early2cell\" , \"mid2cell\" , \"late2cell\" , \"4cell\" , \"8cell\" , \"16cell\" , \"earlyblast\" , \"midblast\" , \"lateblast\" )) We can run a PCA directly on the object of class SingleCellExperiment with the function runPCA : deng_SCE <- scater :: runPCA ( deng_SCE , ncomponents = 50 ) Use the reducedDim function to access the PCA and store the results. pca <- SingleCellExperiment :: reducedDim ( deng_SCE , \"PCA\" ) Describe how the PCA is stored in a matrix. Why does it have this structure? head ( pca ) Add PCA data to the deng_SCE object. deng_SCE $ PC1 <- pca [, 1 ] deng_SCE $ PC2 <- pca [, 2 ] Plot PC biplot with cells colored by cell_type2. colData(deng_SCE) accesses the cell metadata DataFrame object for deng_SCE . Look at Figure 1A of the paper as a comparison to your PC biplot. ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = PC1 , y = PC2 , color = cell_type2 )) + geom_point ( size = 2 , shape = 20 ) + theme_classic () + xlab ( \"PC1\" ) + ylab ( \"PC2\" ) + ggtitle ( \"PC biplot\" ) PCA is a simple approach and can be good to compare to more complex algorithms designed to capture differentiation processes. As a simple measure of pseudotime we can use the coordinates of PC1. Plot PC1 vs cell_type2. deng_SCE $ pseudotime_PC1 <- rank ( deng_SCE $ PC1 ) # rank cells by their PC1 score Create a jitter plot ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = pseudotime_PC1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"PC1\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by first principal component\" ) Read the Slingshot documentation ( ?slingshot::slingshot ) and then run Slingshot below. sce <- slingshot :: slingshot ( deng_SCE , reducedDim = 'PCA' ) Exercise: Given your understanding of the algorithm and the documentation, what is one major set of parameters we omitted here when running Slingshot? Answer We didn\u2019t set the parameter clusterLabels Here is a custom function to plot the PCA based on a slingshot object. Run it in the console to add it to your global environment: PCAplot_slingshot <- function ( sce , draw_lines = TRUE , variable = NULL , legend = FALSE , ... ){ # set palette for factorial variables palf <- colorRampPalette ( RColorBrewer :: brewer.pal ( 8 , \"Set2\" )) # set palette for numeric variables paln <- colorRampPalette ( RColorBrewer :: brewer.pal ( 9 , \"Blues\" )) # extract pca from SingleCellExperiment object pca <- SingleCellExperiment :: reducedDims ( sce ) $ PCA if ( is.null ( variable )){ col <- \"black\" } if ( is.character ( variable )){ variable <- as.factor ( variable ) } if ( is.factor ( variable )){ colpal <- palf ( length ( levels ( variable ))) colors <- colpal [ variable ] } if ( is.numeric ( variable )){ colpal <- paln ( 50 ) colors <- colpal [ cut ( variable , breaks = 50 )] } # draw the plot plot ( pca , bg = colors , pch = 21 ) # draw lines if ( draw_lines ){ lines ( slingshot :: SlingshotDataSet ( sce ), lwd = 2 , ... ) } # add legend if ( legend & is.factor ( variable )){ legend ( \"bottomright\" , pt.bg = colpal , legend = levels ( variable ), pch = 21 ) } } Have a look at the PCA with the slingshot pseudotime line: PCAplot_slingshot ( sce , variable = sce $ slingPseudotime_1 , draw_lines = TRUE ) Also have a look at pseudotime versus cell type: ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = sce $ slingPseudotime_1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) This already looks pretty good. Let\u2019s see whether we can improve it. First we generate clusters by using Seurat : gcdata <- Seurat :: CreateSeuratObject ( counts = SingleCellExperiment :: counts ( deng_SCE ), project = \"slingshot\" ) gcdata <- Seurat :: NormalizeData ( object = gcdata , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) gcdata <- Seurat :: FindVariableFeatures ( object = gcdata , mean.function = ExpMean , dispersion.function = LogVMR ) gcdata <- Seurat :: ScaleData ( object = gcdata , do.center = T , do.scale = F ) gcdata <- Seurat :: RunPCA ( object = gcdata , pc.genes = gcdata @ var.genes ) gcdata <- Seurat :: FindNeighbors ( gcdata , reduction = \"pca\" , dims = 1 : 5 ) # clustering with resolution of 0.6 gcdata <- Seurat :: FindClusters ( object = gcdata , resolution = 0.6 ) Now we can add these clusters to the slingshot function: deng_SCE $ Seurat_clusters <- as.character ( Idents ( gcdata )) # go from factor to character sce <- slingshot :: slingshot ( deng_SCE , clusterLabels = 'Seurat_clusters' , reducedDim = 'PCA' , start.clus = \"2\" ) Check how the slingshot object has evolved SlingshotDataSet ( sce ) Plot PC1 versus PC2 colored by slingshot pseudotime: PCAplot_slingshot ( sce , variable = sce $ slingPseudotime_2 ) Plot Slingshot pseudotime vs cell stage. ggplot ( data.frame ( cell_type2 = deng_SCE $ cell_type2 , slingPseudotime_1 = sce $ slingPseudotime_1 ), aes ( x = slingPseudotime_1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) ggplot ( data.frame ( cell_type2 = deng_SCE $ cell_type2 , slingPseudotime_2 = sce $ slingPseudotime_2 ), aes ( x = slingPseudotime_2 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) Particularly the later stages, separation seems to improve. Since we have included the Seurat clustering, we can plot the PCA, with colors according to these clusters: PCAplot_slingshot ( sce , variable = deng_SCE $ Seurat_clusters , type = 'lineages' , col = 'black' , legend = TRUE ) PCAplot_slingshot ( sce , variable = deng_SCE $ cell_type2 , type = 'lineages' , col = 'black' , legend = TRUE ) Exercise: Instead of providing an initial cluster, think of an end cluster that would fit this trajectory analysis and perform the slingshot analysis. Does slingshot find the initial cluster corresponding to the biological correct situation? Answer sce <- slingshot :: slingshot ( deng_SCE , clusterLabels = 'Seurat_clusters' , reducedDim = 'PCA' , end.clus = c ( \"0\" , \"3\" , \"5\" )) ## check which would be the best according to bio Clear your environment: rm ( list = ls ()) gc () .rs.restartR () Trajectory analysis with monocle3 This part showcases how you can use monocle3 to perform a trajectory analysis. First load the seu_int dataset: seu_int <- readRDS ( \"seu_int_day3.rds\" ) Load the required package into your environment: library ( monocle3 ) Generate a monocle3 object (with class cell_data_set ) from our Seurat object: feature_names <- as.data.frame ( rownames ( seu_int )) rownames ( feature_names ) <- rownames ( seu_int ) colnames ( feature_names ) <- \"gene_short_name\" seu_int_monocl <- monocle3 :: new_cell_data_set ( seu_int @ assays $ RNA @ counts , cell_metadata = seu_int @ meta.data , gene_metadata = feature_names ) We pre-process the newly created object. What does it involve? Check: ? preprocess_cds Preprocess the dataset: seu_int_monocl <- monocle3 :: preprocess_cds ( seu_int_monocl ) And check out the elbow plot: monocle3 :: plot_pc_variance_explained ( seu_int_monocl ) Perform UMAP using the implementation in the monocle3 package and its default parameters: seu_int_monocl <- monocle3 :: reduce_dimension ( seu_int_monocl , reduction_method = \"UMAP\" ) Plot the monocle3 UMAP coloring cells according to the cluster ID ran with Seurat : monocle3 :: plot_cells ( seu_int_monocl , color_cells_by = \"integrated_snn_res.0.3\" , cell_size = 1 , show_trajectory_graph = FALSE ) monocle3 :: plot_cells ( seu_int_monocl , genes = \"CD79A\" , show_trajectory_graph = FALSE , cell_size = 1 ) Cluster cells using monocle3 \u2018s clustering function: seu_int_monocl <- monocle3 :: cluster_cells ( seu_int_monocl , resolution = 0.00025 ) monocle3 :: plot_cells ( seu_int_monocl , label_cell_groups = F ) monocle3 :: plot_cells ( seu_int_monocl , color_cells_by = \"integrated_snn_res.0.3\" , label_cell_groups = F ) learn graph (i.e. identify trajectory) using monocle3 UMAP and clustering: seu_int_monocl <- monocle3 :: learn_graph ( seu_int_monocl ) monocle3 :: plot_cells ( seu_int_monocl ) Exercise: Find the CD34+ B-cell cluster in the monocle UMAP. This cluster has a high expressession of CD79A and expresses CD34. Answer monocle3 :: plot_cells ( seu_int_monocl , genes = c ( \"CD79A\" , \"CD34\" ), show_trajectory_graph = FALSE , cell_size = 0.7 ) Returns: Cluster 13 has both a high expression of CD79A and CD34. Select the \u201cinitial\u201d cells in the B-cell cluster to calculate pseudotime. The initial cells in this case are the CD34+ B-cells we have just identified. A pop up window will open and you need to click on the \u201cinitial\u201d cells (one node per trajectory), then click \u201cDone\u201d. seu_int_monocl <- monocle3 :: order_cells ( seu_int_monocl ) # monocle3 :: plot_cells ( seu_int_monocl , color_cells_by = \"pseudotime\" , label_cell_groups = F , label_leaves = F , label_branch_points = FALSE , graph_label_size = 1.5 , cell_size = 1 ) In order to find genes which expression is affected by pseudtime, we first have to isolate the B-cell cluster. Therefore, extract all cells in the B-cell cluster with the interactive choose_cells function: seuB <- choose_cells ( seu_int_monocl ) Check whether you have selected the right cells: plot_cells ( seuB , show_trajectory_graph = FALSE , cell_size = 1 ) Now we can use the cells in this trajectory to test which genes are affected by the trajectory: pr_test <- graph_test ( seuB , cores = 4 , neighbor_graph = \"principal_graph\" ) # order by test statistic pr_test <- pr_test [ order ( pr_test $ morans_test_statistic , decreasing = TRUE ),] View ( pr_test ) There are some interesting genes in there, for example related to cell cycling (MKI67, CKS2), related to B-cell development (CD34, MS4A1) and immunoglobulins (IGLL1 and IGLL5). We can plot those in the UMAP: goi <- c ( \"CD34\" , \"MS4A1\" , \"IGLL1\" , \"IGLL5\" , \"MKI67\" , \"CKS2\" ) plot_cells ( seuB , label_cell_groups = FALSE , genes = goi , show_trajectory_graph = FALSE , cell_size = 1 ) But also against pseudotime: seuB @ colData $ monocle_cluster <- clusters ( seuB ) plot_genes_in_pseudotime ( subset ( seuB , rowData ( seuB ) $ gene_short_name %in% goi ), min_expr = 0.5 , color_cells_by = \"monocle_cluster\" )","title":"Trajectory analysis"},{"location":"day3/trajectory_analysis/#material","text":"Download the presentation slingshot vignette monocle3","title":"Material"},{"location":"day3/trajectory_analysis/#exercises","text":"Load the following packages: library ( SingleCellExperiment ) library ( scater ) library ( slingshot ) library ( ggplot2 ) library ( ggbeeswarm )","title":"Exercises"},{"location":"day3/trajectory_analysis/#trajectory-analysis-using-slingshot","text":"This part uses the Deng dataset Read in data. It is an object of class SingleCellExperiment . deng_SCE <- readRDS ( \"data/deng_dataset/deng-reads.rds\" ) Perform the first steps of the analysis. The deng_SCE object contains cells that were isolated at different stages of mouse embryogenesis, from the zygote stage to the late blastula. The levels of the cell type are in alphabetical order. We now change the level order for plotting in developmental order: deng_SCE $ cell_type2 <- factor ( deng_SCE $ cell_type2 , levels = c ( \"zy\" , \"early2cell\" , \"mid2cell\" , \"late2cell\" , \"4cell\" , \"8cell\" , \"16cell\" , \"earlyblast\" , \"midblast\" , \"lateblast\" )) We can run a PCA directly on the object of class SingleCellExperiment with the function runPCA : deng_SCE <- scater :: runPCA ( deng_SCE , ncomponents = 50 ) Use the reducedDim function to access the PCA and store the results. pca <- SingleCellExperiment :: reducedDim ( deng_SCE , \"PCA\" ) Describe how the PCA is stored in a matrix. Why does it have this structure? head ( pca ) Add PCA data to the deng_SCE object. deng_SCE $ PC1 <- pca [, 1 ] deng_SCE $ PC2 <- pca [, 2 ] Plot PC biplot with cells colored by cell_type2. colData(deng_SCE) accesses the cell metadata DataFrame object for deng_SCE . Look at Figure 1A of the paper as a comparison to your PC biplot. ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = PC1 , y = PC2 , color = cell_type2 )) + geom_point ( size = 2 , shape = 20 ) + theme_classic () + xlab ( \"PC1\" ) + ylab ( \"PC2\" ) + ggtitle ( \"PC biplot\" ) PCA is a simple approach and can be good to compare to more complex algorithms designed to capture differentiation processes. As a simple measure of pseudotime we can use the coordinates of PC1. Plot PC1 vs cell_type2. deng_SCE $ pseudotime_PC1 <- rank ( deng_SCE $ PC1 ) # rank cells by their PC1 score Create a jitter plot ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = pseudotime_PC1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"PC1\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by first principal component\" ) Read the Slingshot documentation ( ?slingshot::slingshot ) and then run Slingshot below. sce <- slingshot :: slingshot ( deng_SCE , reducedDim = 'PCA' ) Exercise: Given your understanding of the algorithm and the documentation, what is one major set of parameters we omitted here when running Slingshot? Answer We didn\u2019t set the parameter clusterLabels Here is a custom function to plot the PCA based on a slingshot object. Run it in the console to add it to your global environment: PCAplot_slingshot <- function ( sce , draw_lines = TRUE , variable = NULL , legend = FALSE , ... ){ # set palette for factorial variables palf <- colorRampPalette ( RColorBrewer :: brewer.pal ( 8 , \"Set2\" )) # set palette for numeric variables paln <- colorRampPalette ( RColorBrewer :: brewer.pal ( 9 , \"Blues\" )) # extract pca from SingleCellExperiment object pca <- SingleCellExperiment :: reducedDims ( sce ) $ PCA if ( is.null ( variable )){ col <- \"black\" } if ( is.character ( variable )){ variable <- as.factor ( variable ) } if ( is.factor ( variable )){ colpal <- palf ( length ( levels ( variable ))) colors <- colpal [ variable ] } if ( is.numeric ( variable )){ colpal <- paln ( 50 ) colors <- colpal [ cut ( variable , breaks = 50 )] } # draw the plot plot ( pca , bg = colors , pch = 21 ) # draw lines if ( draw_lines ){ lines ( slingshot :: SlingshotDataSet ( sce ), lwd = 2 , ... ) } # add legend if ( legend & is.factor ( variable )){ legend ( \"bottomright\" , pt.bg = colpal , legend = levels ( variable ), pch = 21 ) } } Have a look at the PCA with the slingshot pseudotime line: PCAplot_slingshot ( sce , variable = sce $ slingPseudotime_1 , draw_lines = TRUE ) Also have a look at pseudotime versus cell type: ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = sce $ slingPseudotime_1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) This already looks pretty good. Let\u2019s see whether we can improve it. First we generate clusters by using Seurat : gcdata <- Seurat :: CreateSeuratObject ( counts = SingleCellExperiment :: counts ( deng_SCE ), project = \"slingshot\" ) gcdata <- Seurat :: NormalizeData ( object = gcdata , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) gcdata <- Seurat :: FindVariableFeatures ( object = gcdata , mean.function = ExpMean , dispersion.function = LogVMR ) gcdata <- Seurat :: ScaleData ( object = gcdata , do.center = T , do.scale = F ) gcdata <- Seurat :: RunPCA ( object = gcdata , pc.genes = gcdata @ var.genes ) gcdata <- Seurat :: FindNeighbors ( gcdata , reduction = \"pca\" , dims = 1 : 5 ) # clustering with resolution of 0.6 gcdata <- Seurat :: FindClusters ( object = gcdata , resolution = 0.6 ) Now we can add these clusters to the slingshot function: deng_SCE $ Seurat_clusters <- as.character ( Idents ( gcdata )) # go from factor to character sce <- slingshot :: slingshot ( deng_SCE , clusterLabels = 'Seurat_clusters' , reducedDim = 'PCA' , start.clus = \"2\" ) Check how the slingshot object has evolved SlingshotDataSet ( sce ) Plot PC1 versus PC2 colored by slingshot pseudotime: PCAplot_slingshot ( sce , variable = sce $ slingPseudotime_2 ) Plot Slingshot pseudotime vs cell stage. ggplot ( data.frame ( cell_type2 = deng_SCE $ cell_type2 , slingPseudotime_1 = sce $ slingPseudotime_1 ), aes ( x = slingPseudotime_1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) ggplot ( data.frame ( cell_type2 = deng_SCE $ cell_type2 , slingPseudotime_2 = sce $ slingPseudotime_2 ), aes ( x = slingPseudotime_2 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) Particularly the later stages, separation seems to improve. Since we have included the Seurat clustering, we can plot the PCA, with colors according to these clusters: PCAplot_slingshot ( sce , variable = deng_SCE $ Seurat_clusters , type = 'lineages' , col = 'black' , legend = TRUE ) PCAplot_slingshot ( sce , variable = deng_SCE $ cell_type2 , type = 'lineages' , col = 'black' , legend = TRUE ) Exercise: Instead of providing an initial cluster, think of an end cluster that would fit this trajectory analysis and perform the slingshot analysis. Does slingshot find the initial cluster corresponding to the biological correct situation? Answer sce <- slingshot :: slingshot ( deng_SCE , clusterLabels = 'Seurat_clusters' , reducedDim = 'PCA' , end.clus = c ( \"0\" , \"3\" , \"5\" )) ## check which would be the best according to bio Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Trajectory analysis using Slingshot"},{"location":"day3/trajectory_analysis/#trajectory-analysis-with-monocle3","text":"This part showcases how you can use monocle3 to perform a trajectory analysis. First load the seu_int dataset: seu_int <- readRDS ( \"seu_int_day3.rds\" ) Load the required package into your environment: library ( monocle3 ) Generate a monocle3 object (with class cell_data_set ) from our Seurat object: feature_names <- as.data.frame ( rownames ( seu_int )) rownames ( feature_names ) <- rownames ( seu_int ) colnames ( feature_names ) <- \"gene_short_name\" seu_int_monocl <- monocle3 :: new_cell_data_set ( seu_int @ assays $ RNA @ counts , cell_metadata = seu_int @ meta.data , gene_metadata = feature_names ) We pre-process the newly created object. What does it involve? Check: ? preprocess_cds Preprocess the dataset: seu_int_monocl <- monocle3 :: preprocess_cds ( seu_int_monocl ) And check out the elbow plot: monocle3 :: plot_pc_variance_explained ( seu_int_monocl ) Perform UMAP using the implementation in the monocle3 package and its default parameters: seu_int_monocl <- monocle3 :: reduce_dimension ( seu_int_monocl , reduction_method = \"UMAP\" ) Plot the monocle3 UMAP coloring cells according to the cluster ID ran with Seurat : monocle3 :: plot_cells ( seu_int_monocl , color_cells_by = \"integrated_snn_res.0.3\" , cell_size = 1 , show_trajectory_graph = FALSE ) monocle3 :: plot_cells ( seu_int_monocl , genes = \"CD79A\" , show_trajectory_graph = FALSE , cell_size = 1 ) Cluster cells using monocle3 \u2018s clustering function: seu_int_monocl <- monocle3 :: cluster_cells ( seu_int_monocl , resolution = 0.00025 ) monocle3 :: plot_cells ( seu_int_monocl , label_cell_groups = F ) monocle3 :: plot_cells ( seu_int_monocl , color_cells_by = \"integrated_snn_res.0.3\" , label_cell_groups = F ) learn graph (i.e. identify trajectory) using monocle3 UMAP and clustering: seu_int_monocl <- monocle3 :: learn_graph ( seu_int_monocl ) monocle3 :: plot_cells ( seu_int_monocl ) Exercise: Find the CD34+ B-cell cluster in the monocle UMAP. This cluster has a high expressession of CD79A and expresses CD34. Answer monocle3 :: plot_cells ( seu_int_monocl , genes = c ( \"CD79A\" , \"CD34\" ), show_trajectory_graph = FALSE , cell_size = 0.7 ) Returns: Cluster 13 has both a high expression of CD79A and CD34. Select the \u201cinitial\u201d cells in the B-cell cluster to calculate pseudotime. The initial cells in this case are the CD34+ B-cells we have just identified. A pop up window will open and you need to click on the \u201cinitial\u201d cells (one node per trajectory), then click \u201cDone\u201d. seu_int_monocl <- monocle3 :: order_cells ( seu_int_monocl ) # monocle3 :: plot_cells ( seu_int_monocl , color_cells_by = \"pseudotime\" , label_cell_groups = F , label_leaves = F , label_branch_points = FALSE , graph_label_size = 1.5 , cell_size = 1 ) In order to find genes which expression is affected by pseudtime, we first have to isolate the B-cell cluster. Therefore, extract all cells in the B-cell cluster with the interactive choose_cells function: seuB <- choose_cells ( seu_int_monocl ) Check whether you have selected the right cells: plot_cells ( seuB , show_trajectory_graph = FALSE , cell_size = 1 ) Now we can use the cells in this trajectory to test which genes are affected by the trajectory: pr_test <- graph_test ( seuB , cores = 4 , neighbor_graph = \"principal_graph\" ) # order by test statistic pr_test <- pr_test [ order ( pr_test $ morans_test_statistic , decreasing = TRUE ),] View ( pr_test ) There are some interesting genes in there, for example related to cell cycling (MKI67, CKS2), related to B-cell development (CD34, MS4A1) and immunoglobulins (IGLL1 and IGLL5). We can plot those in the UMAP: goi <- c ( \"CD34\" , \"MS4A1\" , \"IGLL1\" , \"IGLL5\" , \"MKI67\" , \"CKS2\" ) plot_cells ( seuB , label_cell_groups = FALSE , genes = goi , show_trajectory_graph = FALSE , cell_size = 1 ) But also against pseudotime: seuB @ colData $ monocle_cluster <- clusters ( seuB ) plot_genes_in_pseudotime ( subset ( seuB , rowData ( seuB ) $ gene_short_name %in% goi ), min_expr = 0.5 , color_cells_by = \"monocle_cluster\" )","title":"Trajectory analysis with monocle3"}]}